#
# This document contains portions of Linux kernel source code, included
# to demonstrate how various "/proc" files are generated.  That code,
# while not intended to be compiled/used as presented here, is distributed
# according to the terms of the following license.
#
# (C) 2014 Jim Jones <cnamejj@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

The module ProcRootHandlers.py contains code snippets from kernel source
as comments in each "handler" class where the relevant code sample is
less than 50 lines.  For /proc files where the amount of source code
involved in generating the contents of the file is longer, the sample
code is document here instead.


--- File: /proc/locks

source: fs/locks.c

Excerpts from that code:

#         seq_printf(f, "%lld:%s ", id, pfx);
#         if (IS_POSIX(fl)) {
#                 seq_printf(f, "%6s %s ",
#                              (fl->fl_flags & FL_ACCESS) ? "ACCESS" : "POSIX ",
#                              (inode == NULL) ? "*NOINODE*" :
#                              mandatory_lock(inode) ? "MANDATORY" : "ADVISORY ");
#         } else if (IS_FLOCK(fl)) {
#                 if (fl->fl_type & LOCK_MAND) {
#                         seq_printf(f, "FLOCK  MSNFS     ");
#                 } else {
#                         seq_printf(f, "FLOCK  ADVISORY  ");
#                 }
#         } else if (IS_LEASE(fl)) {
#                 seq_printf(f, "LEASE  ");
#                 if (lease_breaking(fl))
#                         seq_printf(f, "BREAKING  ");
#                 else if (fl->fl_file)
#                         seq_printf(f, "ACTIVE    ");
#                 else
#                         seq_printf(f, "BREAKER   ");
#         } else {
#                 seq_printf(f, "UNKNOWN UNKNOWN  ");
#         }
#         if (fl->fl_type & LOCK_MAND) {
#                 seq_printf(f, "%s ",
#                                (fl->fl_type & LOCK_READ)
#                                ? (fl->fl_type & LOCK_WRITE) ? "RW   " : "READ "
#                                : (fl->fl_type & LOCK_WRITE) ? "WRITE" : "NONE ");
#         } else {
#                 seq_printf(f, "%s ",
#                                (lease_breaking(fl))
#                                ? (fl->fl_type & F_UNLCK) ? "UNLCK" : "READ "
#                                : (fl->fl_type & F_WRLCK) ? "WRITE" : "READ ");
#         }
#         if (inode) {
# #ifdef WE_CAN_BREAK_LSLK_NOW
#                 seq_printf(f, "%d %s:%ld ", fl_pid,
#                                 inode->i_sb->s_id, inode->i_ino);
# #else
#                 /* userspace relies on this representation of dev_t ;-( */
#                 seq_printf(f, "%d %02x:%02x:%ld ", fl_pid,
#                                 MAJOR(inode->i_sb->s_dev),
#                                 MINOR(inode->i_sb->s_dev), inode->i_ino);
# #endif
#         } else {
#                 seq_printf(f, "%d <none>:0 ", fl_pid);
#         }
#         if (IS_POSIX(fl)) {
#                 if (fl->fl_end == OFFSET_MAX)
#                         seq_printf(f, "%Ld EOF\n", fl->fl_start);
#                 else
#                         seq_printf(f, "%Ld %Ld\n", fl->fl_start, fl->fl_end);
#         } else {
#                 seq_printf(f, "0 EOF\n");
#         }



--- File: /proc/meminfo

source: fs/proc/meminfo.c
--and--
source: mm/hugetlb.c
--and--
source: arch/x86/mm/pageattr.c

Excerpts from that code:

# from: fs/proc/meminfo.c
# ---
# 	seq_printf(m,
# 		"MemTotal:       %8lu kB\n"
# 		"MemFree:        %8lu kB\n"
# 		"Buffers:        %8lu kB\n"
# 		"Cached:         %8lu kB\n"
# 		"SwapCached:     %8lu kB\n"
# 		"Active:         %8lu kB\n"
# 		"Inactive:       %8lu kB\n"
# 		"Active(anon):   %8lu kB\n"
# 		"Inactive(anon): %8lu kB\n"
# 		"Active(file):   %8lu kB\n"
# 		"Inactive(file): %8lu kB\n"
# 		"Unevictable:    %8lu kB\n"
# 		"Mlocked:        %8lu kB\n"
# #ifdef CONFIG_HIGHMEM
# 		"HighTotal:      %8lu kB\n"
# 		"HighFree:       %8lu kB\n"
# 		"LowTotal:       %8lu kB\n"
# 		"LowFree:        %8lu kB\n"
# #endif
# #ifndef CONFIG_MMU
# 		"MmapCopy:       %8lu kB\n"
# #endif
# 		"SwapTotal:      %8lu kB\n"
# 		"SwapFree:       %8lu kB\n"
# 		"Dirty:          %8lu kB\n"
# 		"Writeback:      %8lu kB\n"
# 		"AnonPages:      %8lu kB\n"
# 		"Mapped:         %8lu kB\n"
# 		"Shmem:          %8lu kB\n"
# 		"Slab:           %8lu kB\n"
# 		"SReclaimable:   %8lu kB\n"
# 		"SUnreclaim:     %8lu kB\n"
# 		"KernelStack:    %8lu kB\n"
# 		"PageTables:     %8lu kB\n"
# #ifdef CONFIG_QUICKLIST
# 		"Quicklists:     %8lu kB\n"
# #endif
# 		"NFS_Unstable:   %8lu kB\n"
# 		"Bounce:         %8lu kB\n"
# 		"WritebackTmp:   %8lu kB\n"
# 		"CommitLimit:    %8lu kB\n"
# 		"Committed_AS:   %8lu kB\n"
# 		"VmallocTotal:   %8lu kB\n"
# 		"VmallocUsed:    %8lu kB\n"
# 		"VmallocChunk:   %8lu kB\n"
# #ifdef CONFIG_MEMORY_FAILURE
# 		"HardwareCorrupted: %5lu kB\n"
# #endif
# #ifdef CONFIG_TRANSPARENT_HUGEPAGE
# 		"AnonHugePages:  %8lu kB\n"
# #endif
# 		,
# 		K(i.totalram),
# 		K(i.freeram),
# 		K(i.bufferram),
# 		K(cached),
# 		K(total_swapcache_pages),
# 		K(pages[LRU_ACTIVE_ANON]   + pages[LRU_ACTIVE_FILE]),
# 		K(pages[LRU_INACTIVE_ANON] + pages[LRU_INACTIVE_FILE]),
# 		K(pages[LRU_ACTIVE_ANON]),
# 		K(pages[LRU_INACTIVE_ANON]),
# 		K(pages[LRU_ACTIVE_FILE]),
# 		K(pages[LRU_INACTIVE_FILE]),
# 		K(pages[LRU_UNEVICTABLE]),
# 		K(global_page_state(NR_MLOCK)),
# #ifdef CONFIG_HIGHMEM
# 		K(i.totalhigh),
# 		K(i.freehigh),
# 		K(i.totalram-i.totalhigh),
# 		K(i.freeram-i.freehigh),
# #endif
# #ifndef CONFIG_MMU
# 		K((unsigned long) atomic_long_read(&mmap_pages_allocated)),
# #endif
# 		K(i.totalswap),
# 		K(i.freeswap),
# 		K(global_page_state(NR_FILE_DIRTY)),
# 		K(global_page_state(NR_WRITEBACK)),
# #ifdef CONFIG_TRANSPARENT_HUGEPAGE
# 		K(global_page_state(NR_ANON_PAGES)
# 		  + global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *
# 		  HPAGE_PMD_NR),
# #else
# 		K(global_page_state(NR_ANON_PAGES)),
# #endif
# 		K(global_page_state(NR_FILE_MAPPED)),
# 		K(global_page_state(NR_SHMEM)),
# 		K(global_page_state(NR_SLAB_RECLAIMABLE) +
# 				global_page_state(NR_SLAB_UNRECLAIMABLE)),
# 		K(global_page_state(NR_SLAB_RECLAIMABLE)),
# 		K(global_page_state(NR_SLAB_UNRECLAIMABLE)),
# 		global_page_state(NR_KERNEL_STACK) * THREAD_SIZE / 1024,
# 		K(global_page_state(NR_PAGETABLE)),
# #ifdef CONFIG_QUICKLIST
# 		K(quicklist_total_size()),
# #endif
# 		K(global_page_state(NR_UNSTABLE_NFS)),
# 		K(global_page_state(NR_BOUNCE)),
# 		K(global_page_state(NR_WRITEBACK_TEMP)),
# 		K(allowed),
# 		K(committed),
# 		(unsigned long)VMALLOC_TOTAL >> 10,
# 		vmi.used >> 10,
# 		vmi.largest_chunk >> 10
# #ifdef CONFIG_MEMORY_FAILURE
# 		,atomic_long_read(&mce_bad_pages) << (PAGE_SHIFT - 10)
# #endif
# #ifdef CONFIG_TRANSPARENT_HUGEPAGE
# 		,K(global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *
# 		   HPAGE_PMD_NR)
# #endif
# 		);
# 
# 	hugetlb_report_meminfo(m);
# 
# 	arch_report_meminfo(m);
#
# from: mm/hugetlb.c
# ---
#        seq_printf(m,
#                        "HugePages_Total:   %5lu\n"
#                        "HugePages_Free:    %5lu\n"
#                        "HugePages_Rsvd:    %5lu\n"
#                        "HugePages_Surp:    %5lu\n"
#                        "Hugepagesize:   %8lu kB\n",
#                        h->nr_huge_pages,
#                        h->free_huge_pages,
#                        h->resv_huge_pages,
#                        h->surplus_huge_pages,
#                        1UL << (huge_page_order(h) + PAGE_SHIFT - 10));
#
#
# from: arch/x86/mm/pageattr.c
# ---
#         seq_printf(m, "DirectMap4k:    %8lu kB\n",
#                         direct_pages_count[PG_LEVEL_4K] << 2);
# #if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE)
#         seq_printf(m, "DirectMap2M:    %8lu kB\n",
#                         direct_pages_count[PG_LEVEL_2M] << 11);
# #else
#         seq_printf(m, "DirectMap4M:    %8lu kB\n",
#                         direct_pages_count[PG_LEVEL_2M] << 12);
# #endif
# #ifdef CONFIG_X86_64
#         if (direct_gbpages)
#                 seq_printf(m, "DirectMap1G:    %8lu kB\n",
#                         direct_pages_count[PG_LEVEL_1G] << 20);
# #endif



--- File: /proc/slabinfo

source: mm/slub.c
--and--
source: mm/slab.c

Excerpts from that code:

# This one is tricky...  There's kernel code that appears to create and write
# "/proc/slabinfo" in two places.  Both "slub.c" and "slab.c" contain lines that
# would write out info to that file.  I'm including code snippets from both and
# making sure this routine can handle output generated by either.
#
# from: mm/slub.c
# ---
#        seq_printf(m, "%-17s %6lu %6lu %6u %4u %4d", s->name, nr_inuse,
#                   nr_objs, s->size, oo_objects(s->oo),
#                   (1 << oo_order(s->oo)));
#        seq_printf(m, " : tunables %4u %4u %4u", 0, 0, 0);
#        seq_printf(m, " : slabdata %6lu %6lu %6lu", nr_slabs, nr_slabs,
#                   0UL);
#        seq_putc(m, '\n');
#
# from: mm/slab.c
# ---
#
# ...header routine...
# #if STATS
#         seq_puts(m, "slabinfo - version: 2.1 (statistics)\n");
# #else
#         seq_puts(m, "slabinfo - version: 2.1\n");
# #endif
#         seq_puts(m, "# name            <active_objs> <num_objs> <objsize> "
#                  "<objperslab> <pagesperslab>");
#         seq_puts(m, " : tunables <limit> <batchcount> <sharedfactor>");
#         seq_puts(m, " : slabdata <active_slabs> <num_slabs> <sharedavail>");
# #if STATS
#         seq_puts(m, " : globalstat <listallocs> <maxobjs> <grown> <reaped> "
#                  "<error> <maxfreeable> <nodeallocs> <remotefrees> <alienoverflow>");
#         seq_puts(m, " : cpustat <allochit> <allocmiss> <freehit> <freemiss>");
# #endif
#         seq_putc(m, '\n');
#
# ...data entries...
# 	seq_printf(m, "%-17s %6lu %6lu %6u %4u %4d",
# 		   name, active_objs, num_objs, cachep->buffer_size,
# 		   cachep->num, (1 << cachep->gfporder));
# 	seq_printf(m, " : tunables %4u %4u %4u",
# 		   cachep->limit, cachep->batchcount, cachep->shared);
# 	seq_printf(m, " : slabdata %6lu %6lu %6lu",
# 		   active_slabs, num_slabs, shared_avail);
# #if STATS
# 	{			/* list3 stats */
# 		unsigned long high = cachep->high_mark;
# 		unsigned long allocs = cachep->num_allocations;
# 		unsigned long grown = cachep->grown;
# 		unsigned long reaped = cachep->reaped;
# 		unsigned long errors = cachep->errors;
# 		unsigned long max_freeable = cachep->max_freeable;
# 		unsigned long node_allocs = cachep->node_allocs;
# 		unsigned long node_frees = cachep->node_frees;
# 		unsigned long overflows = cachep->node_overflow;
# 
# 		seq_printf(m, " : globalstat %7lu %6lu %5lu %4lu "
# 			   "%4lu %4lu %4lu %4lu %4lu",
# 			   allocs, high, grown,
# 			   reaped, errors, max_freeable, node_allocs,
# 			   node_frees, overflows);
# 	}
# 	/* cpu stats */
# 	{
# 		unsigned long allochit = atomic_read(&cachep->allochit);
# 		unsigned long allocmiss = atomic_read(&cachep->allocmiss);
# 		unsigned long freehit = atomic_read(&cachep->freehit);
# 		unsigned long freemiss = atomic_read(&cachep->freemiss);
# 
# 		seq_printf(m, " : cpustat %6lu %6lu %6lu %6lu",
# 			   allochit, allocmiss, freehit, freemiss);
# 	}
# #endif
# 	seq_putc(m, '\n');



--- File: /proc/mdstat

source: drivers/md/raid10.c
--and--
source: drivers/md/md.c

Excerpts from that code:

# from: drivers/md/raid10.c
# ---
# static void status(struct seq_file *seq, struct mddev *mddev)
# {
#         struct r10conf *conf = mddev->private;
#         int i;
# 
#         if (conf->near_copies < conf->raid_disks)
#                 seq_printf(seq, " %dK chunks", mddev->chunk_sectors / 2);
#         if (conf->near_copies > 1)
#                 seq_printf(seq, " %d near-copies", conf->near_copies);
#         if (conf->far_copies > 1) {
#                 if (conf->far_offset)
#                         seq_printf(seq, " %d offset-copies", conf->far_copies);
#                 else
#                         seq_printf(seq, " %d far-copies", conf->far_copies);
#         }
#         seq_printf(seq, " [%d/%d] [", conf->raid_disks,
#                                         conf->raid_disks - mddev->degraded);
#         for (i = 0; i < conf->raid_disks; i++)
#                 seq_printf(seq, "%s",
#                               conf->mirrors[i].rdev &&
#                               test_bit(In_sync, &conf->mirrors[i].rdev->flags) ? "U" : "_");
#         seq_printf(seq, "]");
# }
#
# from: drivers/md/raid10.c
# ---
# static void status_unused(struct seq_file *seq)
# {
# 
# 	seq_printf(seq, "unused devices: ");
# 
# 	list_for_each_entry(rdev, &pending_raid_disks, same_set) {
# 		char b[BDEVNAME_SIZE];
# 		i++;
# 		seq_printf(seq, "%s ",
# 			      bdevname(rdev->bdev,b));
# 	}
# 	if (!i)
# 		seq_printf(seq, "<none>");
# 
# 	seq_printf(seq, "\n");
# }
# 
# 
# static void status_resync(struct seq_file *seq, struct mddev * mddev)
# {
# 	{
# 		int i, x = per_milli/50, y = 20-x;
# 		seq_printf(seq, "[");
# 		for (i = 0; i < x; i++)
# 			seq_printf(seq, "=");
# 		seq_printf(seq, ">");
# 		for (i = 0; i < y; i++)
# 			seq_printf(seq, ".");
# 		seq_printf(seq, "] ");
# 	}
# 	seq_printf(seq, " %s =%3u.%u%% (%llu/%llu)",
# 		   (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery)?
# 		    "reshape" :
# 		    (test_bit(MD_RECOVERY_CHECK, &mddev->recovery)?
# 		     "check" :
# 		     (test_bit(MD_RECOVERY_SYNC, &mddev->recovery) ?
# 		      "resync" : "recovery"))),
# 		   per_milli/10, per_milli % 10,
# 		   (unsigned long long) resync/2,
# 		   (unsigned long long) max_sectors/2);
# ...code deleted...
# 
# 	seq_printf(seq, " finish=%lu.%lumin", (unsigned long)rt / 60,
# 		   ((unsigned long)rt % 60)/6);
# 
# 	seq_printf(seq, " speed=%ldK/sec", db/2/dt);
# }
# 
# static int md_seq_show(struct seq_file *seq, void *v)
# {
# ...code deleted...
# 
# 	if (v == (void*)1) {
# 		struct md_personality *pers;
# 		seq_printf(seq, "Personalities : ");
# 		spin_lock(&pers_lock);
# 		list_for_each_entry(pers, &pers_list, list)
# 			seq_printf(seq, "[%s] ", pers->name);
# 
# 		spin_unlock(&pers_lock);
# 		seq_printf(seq, "\n");
# 		seq->poll_event = atomic_read(&md_event_count);
# 		return 0;
# 	}
# 	if (v == (void*)2) {
# 		status_unused(seq);
# 		return 0;
# 	}
# 
# 	if (mddev_lock(mddev) < 0)
# 		return -EINTR;
# 
# 	if (mddev->pers || mddev->raid_disks || !list_empty(&mddev->disks)) {
# 		seq_printf(seq, "%s : %sactive", mdname(mddev),
# 						mddev->pers ? "" : "in");
# 		if (mddev->pers) {
# 			if (mddev->ro==1)
# 				seq_printf(seq, " (read-only)");
# 			if (mddev->ro==2)
# 				seq_printf(seq, " (auto-read-only)");
# 			seq_printf(seq, " %s", mddev->pers->name);
# 		}
# 
# 		sectors = 0;
# 		list_for_each_entry(rdev, &mddev->disks, same_set) {
# 			char b[BDEVNAME_SIZE];
# 			seq_printf(seq, " %s[%d]",
# 				bdevname(rdev->bdev,b), rdev->desc_nr);
# 			if (test_bit(WriteMostly, &rdev->flags))
# 				seq_printf(seq, "(W)");
# 			if (test_bit(Faulty, &rdev->flags)) {
# 				seq_printf(seq, "(F)");
# 				continue;
# 			} else if (rdev->raid_disk < 0)
# 				seq_printf(seq, "(S)"); /* spare */
# 			sectors += rdev->sectors;
# 		}
# 
# 		if (!list_empty(&mddev->disks)) {
# 			if (mddev->pers)
# 				seq_printf(seq, "\n      %llu blocks",
# 					   (unsigned long long)
# 					   mddev->array_sectors / 2);
# 			else
# 				seq_printf(seq, "\n      %llu blocks",
# 					   (unsigned long long)sectors / 2);
# 		}
# 		if (mddev->persistent) {
# 			if (mddev->major_version != 0 ||
# 			    mddev->minor_version != 90) {
# 				seq_printf(seq," super %d.%d",
# 					   mddev->major_version,
# 					   mddev->minor_version);
# 			}
# 		} else if (mddev->external)
# 			seq_printf(seq, " super external:%s",
# 				   mddev->metadata_type);
# 		else
# 			seq_printf(seq, " super non-persistent");
# 
# 		if (mddev->pers) {
# 			mddev->pers->status(seq, mddev);
# 	 		seq_printf(seq, "\n      ");
# 			if (mddev->pers->sync_request) {
# 				if (mddev->curr_resync > 2) {
# 					status_resync(seq, mddev);
# 					seq_printf(seq, "\n      ");
# 				} else if (mddev->curr_resync == 1 || mddev->curr_resync == 2)
# 					seq_printf(seq, "\tresync=DELAYED\n      ");
# 				else if (mddev->recovery_cp < MaxSector)
# 					seq_printf(seq, "\tresync=PENDING\n      ");
# 			}
# 		} else
# 			seq_printf(seq, "\n       ");
# 
# 		if ((bitmap = mddev->bitmap)) {
# 			unsigned long chunk_kb;
# 			unsigned long flags;
# 			spin_lock_irqsave(&bitmap->lock, flags);
# 			chunk_kb = mddev->bitmap_info.chunksize >> 10;
# 			seq_printf(seq, "bitmap: %lu/%lu pages [%luKB], "
# 				"%lu%s chunk",
# 				bitmap->pages - bitmap->missing_pages,
# 				bitmap->pages,
# 				(bitmap->pages - bitmap->missing_pages)
# 					<< (PAGE_SHIFT - 10),
# 				chunk_kb ? chunk_kb : mddev->bitmap_info.chunksize,
# 				chunk_kb ? "KB" : "B");
# 			if (bitmap->file) {
# 				seq_printf(seq, ", file: ");
# 				seq_path(seq, &bitmap->file->f_path, " \t\n");
# 			}
# 
# 			seq_printf(seq, "\n");
# 			spin_unlock_irqrestore(&bitmap->lock, flags);
# 		}
# 
# 		seq_printf(seq, "\n");
# 	}
# 	mddev_unlock(mddev);
# 	
# 	return 0;
# }



--- File: /proc/mounts

source: fs/namespace.c

Excerpts from that code:

#static int show_vfsmnt(struct seq_file *m, void *v)
#{
#        struct vfsmount *mnt = list_entry(v, struct vfsmount, mnt_list);
#        int err = 0;
#        struct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };
#
#        if (mnt->mnt_sb->s_op->show_devname) {
#                err = mnt->mnt_sb->s_op->show_devname(m, mnt);
#                if (err)
#                        goto out;
#        } else {
#                mangle(m, mnt->mnt_devname ? mnt->mnt_devname : "none");
#        }
#        seq_putc(m, ' ');
#        seq_path(m, &mnt_path, " \t\n\\");
#        seq_putc(m, ' ');
#        show_type(m, mnt->mnt_sb);
#        seq_puts(m, __mnt_is_readonly(mnt) ? " ro" : " rw");
#        err = show_sb_opts(m, mnt->mnt_sb);
#        if (err)
#                goto out;
#        show_mnt_opts(m, mnt);
#        if (mnt->mnt_sb->s_op->show_options)
#                err = mnt->mnt_sb->s_op->show_options(m, mnt);
#        seq_puts(m, " 0 0\n");
#out:
#        return err;
#}



--- File: /proc/stat

source: fs/proc/stat.c

Excerpts from that code:

#static int show_stat(struct seq_file *p, void *v)
#{
#	int i, j;
#	unsigned long jif;
#	cputime64_t user, nice, system, idle, iowait, irq, softirq, steal;
#	cputime64_t guest, guest_nice;
#	u64 sum = 0;
#	u64 sum_softirq = 0;
#	unsigned int per_softirq_sums[NR_SOFTIRQS] = {0};
#	struct timespec boottime;
#
#	user = nice = system = idle = iowait =
#		irq = softirq = steal = cputime64_zero;
#	guest = guest_nice = cputime64_zero;
#	getboottime(&boottime);
#	jif = boottime.tv_sec;
#
#	for_each_possible_cpu(i) {
#		user = cputime64_add(user, kstat_cpu(i).cpustat.user);
#		nice = cputime64_add(nice, kstat_cpu(i).cpustat.nice);
#		system = cputime64_add(system, kstat_cpu(i).cpustat.system);
#		idle = cputime64_add(idle, get_idle_time(i));
#		iowait = cputime64_add(iowait, get_iowait_time(i));
#		irq = cputime64_add(irq, kstat_cpu(i).cpustat.irq);
#		softirq = cputime64_add(softirq, kstat_cpu(i).cpustat.softirq);
#		steal = cputime64_add(steal, kstat_cpu(i).cpustat.steal);
#		guest = cputime64_add(guest, kstat_cpu(i).cpustat.guest);
#		guest_nice = cputime64_add(guest_nice,
#			kstat_cpu(i).cpustat.guest_nice);
#		sum += kstat_cpu_irqs_sum(i);
#		sum += arch_irq_stat_cpu(i);
#
#		for (j = 0; j < NR_SOFTIRQS; j++) {
#			unsigned int softirq_stat = kstat_softirqs_cpu(j, i);
#
#			per_softirq_sums[j] += softirq_stat;
#			sum_softirq += softirq_stat;
#		}
#	}
#	sum += arch_irq_stat();
#
#	seq_printf(p, "cpu  %llu %llu %llu %llu %llu %llu %llu %llu %llu "
#		"%llu\n",
#		(unsigned long long)cputime64_to_clock_t(user),
#		(unsigned long long)cputime64_to_clock_t(nice),
#		(unsigned long long)cputime64_to_clock_t(system),
#		(unsigned long long)cputime64_to_clock_t(idle),
#		(unsigned long long)cputime64_to_clock_t(iowait),
#		(unsigned long long)cputime64_to_clock_t(irq),
#		(unsigned long long)cputime64_to_clock_t(softirq),
#		(unsigned long long)cputime64_to_clock_t(steal),
#		(unsigned long long)cputime64_to_clock_t(guest),
#		(unsigned long long)cputime64_to_clock_t(guest_nice));
#	for_each_online_cpu(i) {
#		/* Copy values here to work around gcc-2.95.3, gcc-2.96 */
#		user = kstat_cpu(i).cpustat.user;
#		nice = kstat_cpu(i).cpustat.nice;
#		system = kstat_cpu(i).cpustat.system;
#		idle = get_idle_time(i);
#		iowait = get_iowait_time(i);
#		irq = kstat_cpu(i).cpustat.irq;
#		softirq = kstat_cpu(i).cpustat.softirq;
#		steal = kstat_cpu(i).cpustat.steal;
#		guest = kstat_cpu(i).cpustat.guest;
#		guest_nice = kstat_cpu(i).cpustat.guest_nice;
#		seq_printf(p,
#			"cpu%d %llu %llu %llu %llu %llu %llu %llu %llu %llu "
#			"%llu\n",
#			i,
#			(unsigned long long)cputime64_to_clock_t(user),
#			(unsigned long long)cputime64_to_clock_t(nice),
#			(unsigned long long)cputime64_to_clock_t(system),
#			(unsigned long long)cputime64_to_clock_t(idle),
#			(unsigned long long)cputime64_to_clock_t(iowait),
#			(unsigned long long)cputime64_to_clock_t(irq),
#			(unsigned long long)cputime64_to_clock_t(softirq),
#			(unsigned long long)cputime64_to_clock_t(steal),
#			(unsigned long long)cputime64_to_clock_t(guest),
#			(unsigned long long)cputime64_to_clock_t(guest_nice));
#	}
#	seq_printf(p, "intr %llu", (unsigned long long)sum);
#
#	/* sum again ? it could be updated? */
#	for_each_irq_nr(j)
#		seq_printf(p, " %u", kstat_irqs(j));
#
#	seq_printf(p,
#		"\nctxt %llu\n"
#		"btime %lu\n"
#		"processes %lu\n"
#		"procs_running %lu\n"
#		"procs_blocked %lu\n",
#		nr_context_switches(),
#		(unsigned long)jif,
#		total_forks,
#		nr_running(),
#		nr_iowait());
#
#	seq_printf(p, "softirq %llu", (unsigned long long)sum_softirq);
#
#	for (i = 0; i < NR_SOFTIRQS; i++)
#		seq_printf(p, " %u", per_softirq_sums[i]);
#	seq_putc(p, '\n');
#
#	return 0;
#}



--- File: /proc/interrupts

source: kernel/irq/proc.c
--and--
source: arch/frv/kernel/irq.c
--and--
source: arch/xtensa/kernel/irq.c
--and--
source: arch/m68k/kernel/irq.c
--and--
source: arch/mips/kernel/irq.c
--and--
source: arch/ia64/kernel/irq.c
--and--
source: arch/powerpc/kernel/irq.c
--and--
source: arch/arm/kernel/irq.c
--and--
source: arch/alpha/kernel/irq.c
--and--
source: arch/mn10300/kernel/irq.c
--and--
source: arch/x86/kernel/irq.c
--and--
source: arch/sh/kernel/irq.c
--and--
source: arch/sparc/kernel/irq_32.c
--and--
source: arch/sparc/kernel/irq_64.c
--and--
source: arch/x86/kernel/apic/io_apic.c
--and--
source: arch/arm/kernel/fiq.c
--and--
source: arch/arm/kernel/smp.c

# from: kernel/irq/proc.c
# ---
#int show_interrupts(struct seq_file *p, void *v)
#{
#        static int prec;
#
#        unsigned long flags, any_count = 0;
#        int i = *(loff_t *) v, j;
#        struct irqaction *action;
#        struct irq_desc *desc;
#
#        if (i > ACTUAL_NR_IRQS)
#                return 0;
#
#        if (i == ACTUAL_NR_IRQS)
#                return arch_show_interrupts(p, prec);
#
#        /* print header and calculate the width of the first column */
#        if (i == 0) {
#                for (prec = 3, j = 1000; prec < 10 && j <= nr_irqs; ++prec)
#                        j *= 10;
#
#                seq_printf(p, "%*s", prec + 8, "");
#                for_each_online_cpu(j)
#                        seq_printf(p, "CPU%-8d", j);
#                seq_putc(p, '\n');
#        }
#
#        desc = irq_to_desc(i);
#        if (!desc)
#                return 0;
#
#        raw_spin_lock_irqsave(&desc->lock, flags);
#        for_each_online_cpu(j)
#                any_count |= kstat_irqs_cpu(i, j);
#        action = desc->action;
#        if (!action && !any_count)
#                goto out;
#
#        seq_printf(p, "%*d: ", prec, i);
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", kstat_irqs_cpu(i, j));
#
#        if (desc->irq_data.chip) {
#                if (desc->irq_data.chip->irq_print_chip)
#                        desc->irq_data.chip->irq_print_chip(&desc->irq_data, p);
#                else if (desc->irq_data.chip->name)
#                        seq_printf(p, " %8s", desc->irq_data.chip->name);
#                else
#                        seq_printf(p, " %8s", "-");
#        } else {
#                seq_printf(p, " %8s", "None");
#        }
##ifdef CONFIG_GENERIC_IRQ_SHOW_LEVEL
#        seq_printf(p, " %-8s", irqd_is_level_type(&desc->irq_data) ? "Level" : "Edge");
##endif
#        if (desc->name)
#                seq_printf(p, "-%-8s", desc->name);
#
#        if (action) {
#                seq_printf(p, "  %s", action->name);
#                while ((action = action->next) != NULL)
#                        seq_printf(p, ", %s", action->name);
#        }
#
#        seq_putc(p, '\n');
#out:
#        raw_spin_unlock_irqrestore(&desc->lock, flags);
#        return 0;
#}
##endif
#
# from: arch/frv/kernel/irq.c -and- arch/xtensa/kernel/irq.c
# Both use the same code:
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
#        seq_printf(p, "%*s: ", prec, "ERR");
#        seq_printf(p, "%10u\n", atomic_read(&irq_err_count));
#        return 0;
#}
#
# from: arch/m68k/kernel/irq.c -and- arch/mips/kernel/irq.c
# Both use the same code:
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
#        seq_printf(p, "%*s: %10u\n", prec, "ERR", atomic_read(&irq_err_count));
#        return 0;
#}
#
# from: arch/ia64/kernel/irq.c
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
#        seq_printf(p, "ERR: %10u\n", atomic_read(&irq_err_count));
#        return 0;
#}
#
# from: arch/powerpc/kernel/irq.c
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
#        int j;
#
##if defined(CONFIG_PPC32) && defined(CONFIG_TAU_INT)
#        if (tau_initialized) {
#                seq_printf(p, "%*s: ", prec, "TAU");
#                for_each_online_cpu(j)
#                        seq_printf(p, "%10u ", tau_interrupts(j));
#                seq_puts(p, "  PowerPC             Thermal Assist (cpu temp)\n");
#        }
##endif /* CONFIG_PPC32 && CONFIG_TAU_INT */
#
#        seq_printf(p, "%*s: ", prec, "LOC");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", per_cpu(irq_stat, j).timer_irqs);
#        seq_printf(p, "  Local timer interrupts\n");
#
#        seq_printf(p, "%*s: ", prec, "SPU");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", per_cpu(irq_stat, j).spurious_irqs);
#        seq_printf(p, "  Spurious interrupts\n");
#
#        seq_printf(p, "%*s: ", prec, "CNT");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", per_cpu(irq_stat, j).pmu_irqs);
#        seq_printf(p, "  Performance monitoring interrupts\n");
#
#        seq_printf(p, "%*s: ", prec, "MCE");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", per_cpu(irq_stat, j).mce_exceptions);
#        seq_printf(p, "  Machine check exceptions\n");
#
#        return 0;
#}
#
# from: arch/arm/kernel/irq.c
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
##ifdef CONFIG_FIQ
#        show_fiq_list(p, prec);
##endif
##ifdef CONFIG_SMP
#        show_ipi_list(p, prec);
##endif
#        seq_printf(p, "%*s: %10lu\n", prec, "Err", irq_err_count);
#        return 0;
#}
#
# from: arch/alpha/kernel/irq.c
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
#        int j;
#
##ifdef CONFIG_SMP
#        seq_puts(p, "IPI: ");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10lu ", cpu_data[j].ipi_count);
#        seq_putc(p, '\n');
##endif
#        seq_puts(p, "PMI: ");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10lu ", per_cpu(irq_pmi_count, j));
#        seq_puts(p, "          Performance Monitoring\n");
#        seq_printf(p, "ERR: %10lu\n", irq_err_count);
#        return 0;
#}
#
# from: arch/mn10300/kernel/irq.c
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
##ifdef CONFIG_MN10300_WD_TIMER
#        int j;
#
#        seq_printf(p, "%*s: ", prec, "NMI");
#        for (j = 0; j < NR_CPUS; j++)
#                if (cpu_online(j))
#                        seq_printf(p, "%10u ", nmi_count(j));
#        seq_putc(p, '\n');
##endif
#
#        seq_printf(p, "%*s: ", prec, "ERR");
#        seq_printf(p, "%10u\n", atomic_read(&irq_err_count));
#        return 0;
#}
#
# from: arch/x86/kernel/irq.c
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
#        int j;
#
#        seq_printf(p, "%*s: ", prec, "NMI");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->__nmi_count);
#        seq_printf(p, "  Non-maskable interrupts\n");
##ifdef CONFIG_X86_LOCAL_APIC
#        seq_printf(p, "%*s: ", prec, "LOC");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->apic_timer_irqs);
#        seq_printf(p, "  Local timer interrupts\n");
#
#        seq_printf(p, "%*s: ", prec, "SPU");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->irq_spurious_count);
#        seq_printf(p, "  Spurious interrupts\n");
#        seq_printf(p, "%*s: ", prec, "PMI");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->apic_perf_irqs);
#        seq_printf(p, "  Performance monitoring interrupts\n");
#        seq_printf(p, "%*s: ", prec, "IWI");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->apic_irq_work_irqs);
#        seq_printf(p, "  IRQ work interrupts\n");
##endif
#        if (x86_platform_ipi_callback) {
#                seq_printf(p, "%*s: ", prec, "PLT");
#                for_each_online_cpu(j)
#                        seq_printf(p, "%10u ", irq_stats(j)->x86_platform_ipis);
#                seq_printf(p, "  Platform interrupts\n");
#        }
##ifdef CONFIG_SMP
#        seq_printf(p, "%*s: ", prec, "RES");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->irq_resched_count);
#        seq_printf(p, "  Rescheduling interrupts\n");
#        seq_printf(p, "%*s: ", prec, "CAL");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->irq_call_count);
#        seq_printf(p, "  Function call interrupts\n");
#        seq_printf(p, "%*s: ", prec, "TLB");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->irq_tlb_count);
#        seq_printf(p, "  TLB shootdowns\n");
##endif
##ifdef CONFIG_X86_THERMAL_VECTOR
#        seq_printf(p, "%*s: ", prec, "TRM");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->irq_thermal_count);
#        seq_printf(p, "  Thermal event interrupts\n");
##endif
##ifdef CONFIG_X86_MCE_THRESHOLD
#        seq_printf(p, "%*s: ", prec, "THR");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stats(j)->irq_threshold_count);
#        seq_printf(p, "  Threshold APIC interrupts\n");
##endif
##ifdef CONFIG_X86_MCE
#        seq_printf(p, "%*s: ", prec, "MCE");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", per_cpu(mce_exception_count, j));
#        seq_printf(p, "  Machine check exceptions\n");
#        seq_printf(p, "%*s: ", prec, "MCP");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", per_cpu(mce_poll_count, j));
#        seq_printf(p, "  Machine check polls\n");
##endif
#        seq_printf(p, "%*s: %10u\n", prec, "ERR", atomic_read(&irq_err_count));
##if defined(CONFIG_X86_IO_APIC)
#        seq_printf(p, "%*s: %10u\n", prec, "MIS", atomic_read(&irq_mis_count));
##endif
#        return 0;
#}
#
# from: arch/sh/kernel/irq.c
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
#        int j;
#
#        seq_printf(p, "%*s: ", prec, "NMI");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", irq_stat[j].__nmi_count);
#        seq_printf(p, "  Non-maskable interrupts\n");
#
#        seq_printf(p, "%*s: %10u\n", prec, "ERR", atomic_read(&irq_err_count));
#
#        return 0;
#}
#
# from: arch/sparc/kernel/irq_32.c
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
#        int j;
#
##ifdef CONFIG_SMP
#        seq_printf(p, "RES: ");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", cpu_data(j).irq_resched_count);
#        seq_printf(p, "     IPI rescheduling interrupts\n");
#        seq_printf(p, "CAL: ");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", cpu_data(j).irq_call_count);
#        seq_printf(p, "     IPI function call interrupts\n");
##endif
#        seq_printf(p, "NMI: ");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", cpu_data(j).counter);
#        seq_printf(p, "     Non-maskable interrupts\n");
#        return 0;
#}
#
# from: arch/sparc/kernel/irq_64.c
# ---
#int arch_show_interrupts(struct seq_file *p, int prec)
#{
#        int j;
#
#        seq_printf(p, "NMI: ");
#        for_each_online_cpu(j)
#                seq_printf(p, "%10u ", cpu_data(j).__nmi_count);
#        seq_printf(p, "     Non-maskable interrupts\n");
#        return 0;
#}
#
# from: arch/x86/kernel/apic/io_apic.c
# ---
#static void ir_print_prefix(struct irq_data *data, struct seq_file *p)
#{
#        seq_printf(p, " IR-%s", data->chip->name);
#}
#
# from: arch/arm/kernel/fiq.c
# ---
#int show_fiq_list(struct seq_file *p, int prec)
#{
#        if (current_fiq != &default_owner)
#                seq_printf(p, "%*s:              %s\n", prec, "FIQ",
#                        current_fiq->name);
#
#        return 0;
#}
#
# from: arch/arm/kernel/smp.c
# ---
#void show_ipi_list(struct seq_file *p, int prec)
#{
#        unsigned int cpu, i;
#
#        for (i = 0; i < NR_IPI; i++) {
#                seq_printf(p, "%*s%u: ", prec - 1, "IPI", i);
#
#                for_each_present_cpu(cpu)
#                        seq_printf(p, "%10u ",
#                                   __get_irq_stat(cpu, ipi_irqs[i]));
#
#                seq_printf(p, " %s\n", ipi_types[i]);
#        }
#}



--- File: /proc/zoneinfo

source: mm/vmstat.c

Excerpts from that code:

#static void zoneinfo_show_print(struct seq_file *m, pg_data_t *pgdat,
#                                                        struct zone *zone)
#{
#        int i;
#        seq_printf(m, "Node %d, zone %8s", pgdat->node_id, zone->name);
#        seq_printf(m,
#                   "\n  pages free     %lu"
#                   "\n        min      %lu"
#                   "\n        low      %lu"
#                   "\n        high     %lu"
#                   "\n        scanned  %lu"
#                   "\n        spanned  %lu"
#                   "\n        present  %lu",
#                   zone_page_state(zone, NR_FREE_PAGES),
#                   min_wmark_pages(zone),
#                   low_wmark_pages(zone),
#                   high_wmark_pages(zone),
#                   zone->pages_scanned,
#                   zone->spanned_pages,
#                   zone->present_pages);
#
#        for (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)
#                seq_printf(m, "\n    %-12s %lu", vmstat_text[i],
#                                zone_page_state(zone, i));
#
#        seq_printf(m,
#                   "\n        protection: (%lu",
#                   zone->lowmem_reserve[0]);
#        for (i = 1; i < ARRAY_SIZE(zone->lowmem_reserve); i++)
#                seq_printf(m, ", %lu", zone->lowmem_reserve[i]);
#        seq_printf(m,
#                   ")"
#                   "\n  pagesets");
#        for_each_online_cpu(i) {
#                struct per_cpu_pageset *pageset;
#
#                pageset = per_cpu_ptr(zone->pageset, i);
#                seq_printf(m,
#                           "\n    cpu: %i"
#                           "\n              count: %i"
#                           "\n              high:  %i"
#                           "\n              batch: %i",
#                           i,
#                           pageset->pcp.count,
#                           pageset->pcp.high,
#                           pageset->pcp.batch);
##ifdef CONFIG_SMP
#                seq_printf(m, "\n  vm stats threshold: %d",
#                                pageset->stat_threshold);
##endif
#        }
#        seq_printf(m,
#                   "\n  all_unreclaimable: %u"
#                   "\n  start_pfn:         %lu"
#                   "\n  inactive_ratio:    %u",
#                   zone->all_unreclaimable,
#                   zone->zone_start_pfn,
#                   zone->inactive_ratio);
#        seq_putc(m, '\n');
#}
