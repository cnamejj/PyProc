#
# This document contains portions of Linux kernel source code, included
# to demonstrate how various "/proc" files are generated.  That code,
# while not intended to be compiled/used as presented here, is distributed
# according to the terms of the following license.
#
# (C) 2014 Jim Jones <cnamejj@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

The module ProcRootHandlers.py contains code snippets from kernel source
as comments in each "handler" class where the relevant code sample is
less than 50 lines.  For /proc files where the amount of source code
involved in generating the contents of the file is longer, the sample
code is document here instead.


--- File: /proc/self/mountinfo

source: fs/namespace.c

Excerpts from that code:

#        seq_printf(m, "%i %i %u:%u ", mnt->mnt_id, mnt->mnt_parent->mnt_id,
#                   MAJOR(sb->s_dev), MINOR(sb->s_dev));
#        if (sb->s_op->show_path)
#                err = sb->s_op->show_path(m, mnt);
#        else
#                seq_dentry(m, mnt->mnt_root, " \t\n\\");
#        if (err)
#                goto out;
#        seq_putc(m, ' ');
#
#        /* mountpoints outside of chroot jail will give SEQ_SKIP on this */
#        err = seq_path_root(m, &mnt_path, &root, " \t\n\\");
#        if (err)
#                goto out;
#
#        seq_puts(m, mnt->mnt_flags & MNT_READONLY ? " ro" : " rw");
#        show_mnt_opts(m, mnt);
#
#        /* Tagged fields ("foo:X" or "bar") */
#        if (IS_MNT_SHARED(mnt))
#                seq_printf(m, " shared:%i", mnt->mnt_group_id);
#        if (IS_MNT_SLAVE(mnt)) {
#                int master = mnt->mnt_master->mnt_group_id;
#                int dom = get_dominating_id(mnt, &p->root);
#                seq_printf(m, " master:%i", master);
#                if (dom && dom != master)
#                        seq_printf(m, " propagate_from:%i", dom);
#        }
#        if (IS_MNT_UNBINDABLE(mnt))
#                seq_puts(m, " unbindable");
#
#        /* Filesystem specific data */
#        seq_puts(m, " - ");
#        show_type(m, sb);
#        seq_putc(m, ' ');
#        if (sb->s_op->show_devname)
#                err = sb->s_op->show_devname(m, mnt);
#        else
#                mangle(m, mnt->mnt_devname ? mnt->mnt_devname : "none");
#        if (err)
#                goto out;
#        seq_puts(m, sb->s_flags & MS_RDONLY ? " ro" : " rw");
#        err = show_sb_opts(m, sb);
#        if (err)
#                goto out;
#        if (sb->s_op->show_options)
#                err = sb->s_op->show_options(m, mnt);
#        seq_putc(m, '\n');
#
# --and--
#
# static void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)
# {
#        static const struct proc_fs_info mnt_info[] = {
#                { MNT_NOSUID, ",nosuid" },
#                { MNT_NODEV, ",nodev" },
#                { MNT_NOEXEC, ",noexec" },
#                { MNT_NOATIME, ",noatime" },
#                { MNT_NODIRATIME, ",nodiratime" },
#                { MNT_RELATIME, ",relatime" },
#                { 0, NULL }
#        };
#        const struct proc_fs_info *fs_infop;
#
#        for (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {
#                if (mnt->mnt_flags & fs_infop->flag)
#                        seq_puts(m, fs_infop->str);
#        }
# }




--- File: /proc/self/mountstats

source: fs/namespace.c
--and--
source: fs/nfs/super.c
--and--
source: net/sunrpc/xprtsock.c
--and--
source: net/sunrpc/stats.c

Excerpts from that code:

# from: fs/namespace.c
# --------
# 
# static int show_vfsstat(struct seq_file *m, void *v)
# {
#         struct vfsmount *mnt = list_entry(v, struct vfsmount, mnt_list);
#         struct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };
#         int err = 0;
# 
#         /* device */
#         if (mnt->mnt_sb->s_op->show_devname) {
#                 seq_puts(m, "device ");
#                 err = mnt->mnt_sb->s_op->show_devname(m, mnt);
#         } else {
#                 if (mnt->mnt_devname) {
#                         seq_puts(m, "device ");
#                         mangle(m, mnt->mnt_devname);
#                 } else
#                         seq_puts(m, "no device");
#         }
# 
#         /* mount point */
#         seq_puts(m, " mounted on ");
#         seq_path(m, &mnt_path, " \t\n\\");
#         seq_putc(m, ' ');
# 
#         /* file system type */
#         seq_puts(m, "with fstype ");
#         show_type(m, mnt->mnt_sb);
# 
#         /* optional statistics */
#         if (mnt->mnt_sb->s_op->show_stats) {
#                 seq_putc(m, ' ');
#                 if (!err)
#                         err = mnt->mnt_sb->s_op->show_stats(m, mnt);
#         }
# 
#         seq_putc(m, '\n');
#         return err;
# }
# 
# 
# from: fs/nfs/super.c
# --------
# 
# static int nfs_show_stats(struct seq_file *m, struct vfsmount *mnt)
# {
#         int i, cpu;
#         struct nfs_server *nfss = NFS_SB(mnt->mnt_sb);
#         struct rpc_auth *auth = nfss->client->cl_auth;
#         struct nfs_iostats totals = { };
# 
#         seq_printf(m, "statvers=%s", NFS_IOSTAT_VERS);
# 
#         /*
#          * Display all mount option settings
#          */
#         seq_printf(m, "\n\topts:\t");
#         seq_puts(m, mnt->mnt_sb->s_flags & MS_RDONLY ? "ro" : "rw");
#         seq_puts(m, mnt->mnt_sb->s_flags & MS_SYNCHRONOUS ? ",sync" : "");
#         seq_puts(m, mnt->mnt_sb->s_flags & MS_NOATIME ? ",noatime" : "");
#         seq_puts(m, mnt->mnt_sb->s_flags & MS_NODIRATIME ? ",nodiratime" : "");
#         nfs_show_mount_options(m, nfss, 1);
# 
#         seq_printf(m, "\n\tage:\t%lu", (jiffies - nfss->mount_time) / HZ);
# 
#         seq_printf(m, "\n\tcaps:\t");
#         seq_printf(m, "caps=0x%x", nfss->caps);
#         seq_printf(m, ",wtmult=%u", nfss->wtmult);
#         seq_printf(m, ",dtsize=%u", nfss->dtsize);
#         seq_printf(m, ",bsize=%u", nfss->bsize);
#         seq_printf(m, ",namlen=%u", nfss->namelen);
# 
# #ifdef CONFIG_NFS_V4
#         if (nfss->nfs_client->rpc_ops->version == 4) {
#                 seq_printf(m, "\n\tnfsv4:\t");
#                 seq_printf(m, "bm0=0x%x", nfss->attr_bitmask[0]);
#                 seq_printf(m, ",bm1=0x%x", nfss->attr_bitmask[1]);
#                 seq_printf(m, ",acl=0x%x", nfss->acl_bitmask);
#                 show_sessions(m, nfss);
#                 show_pnfs(m, nfss);
#         }
# #endif
# 
#         /*
#          * Display security flavor in effect for this mount
#          */
#         seq_printf(m, "\n\tsec:\tflavor=%u", auth->au_ops->au_flavor);
#         if (auth->au_flavor)
#                 seq_printf(m, ",pseudoflavor=%u", auth->au_flavor);
# 
#         /*
#          * Display superblock I/O counters
#          */
#         for_each_possible_cpu(cpu) {
#                 struct nfs_iostats *stats;
# 
#                 preempt_disable();
#                 stats = per_cpu_ptr(nfss->io_stats, cpu);
# 
#                 for (i = 0; i < __NFSIOS_COUNTSMAX; i++)
#                         totals.events[i] += stats->events[i];
#                 for (i = 0; i < __NFSIOS_BYTESMAX; i++)
#                         totals.bytes[i] += stats->bytes[i];
# #ifdef CONFIG_NFS_FSCACHE
#                 for (i = 0; i < __NFSIOS_FSCACHEMAX; i++)
#                         totals.fscache[i] += stats->fscache[i];
# #endif
# 
#                 preempt_enable();
#         }
# 
#         seq_printf(m, "\n\tevents:\t");
#         for (i = 0; i < __NFSIOS_COUNTSMAX; i++)
#                 seq_printf(m, "%lu ", totals.events[i]);
#         seq_printf(m, "\n\tbytes:\t");
#         for (i = 0; i < __NFSIOS_BYTESMAX; i++)
#                 seq_printf(m, "%Lu ", totals.bytes[i]);
# #ifdef CONFIG_NFS_FSCACHE
#         if (nfss->options & NFS_OPTION_FSCACHE) {
#                 seq_printf(m, "\n\tfsc:\t");
#                 for (i = 0; i < __NFSIOS_FSCACHEMAX; i++)
#                         seq_printf(m, "%Lu ", totals.bytes[i]);
#         }
# #endif
#         seq_printf(m, "\n");
# 
#         rpc_print_iostats(m, nfss->client);
# 
#         return 0;
# }
# 
# static void show_sessions(struct seq_file *m, struct nfs_server *server)
# {
#         if (nfs4_has_session(server->nfs_client))
#                 seq_printf(m, ",sessions");
# }
# 
# static void show_pnfs(struct seq_file *m, struct nfs_server *server)
# {
#         seq_printf(m, ",pnfs=");
#         if (server->pnfs_curr_ld)
#                 seq_printf(m, "%s", server->pnfs_curr_ld->name);
#         else
#                 seq_printf(m, "not configured");
# }
# 
# 
# static void nfs_show_mount_options(struct seq_file *m, struct nfs_server *nfss,
#                                    int showdefaults)
# {
#         static const struct proc_nfs_info {
#                 int flag;
#                 const char *str;
#                 const char *nostr;
#         } nfs_info[] = {
#                 { NFS_MOUNT_SOFT, ",soft", ",hard" },
#                 { NFS_MOUNT_POSIX, ",posix", "" },
#                 { NFS_MOUNT_NOCTO, ",nocto", "" },
#                 { NFS_MOUNT_NOAC, ",noac", "" },
#                 { NFS_MOUNT_NONLM, ",nolock", "" },
#                 { NFS_MOUNT_NOACL, ",noacl", "" },
#                 { NFS_MOUNT_NORDIRPLUS, ",nordirplus", "" },
#                 { NFS_MOUNT_UNSHARED, ",nosharecache", "" },
#                 { NFS_MOUNT_NORESVPORT, ",noresvport", "" },
#                 { 0, NULL, NULL }
#         };
#         const struct proc_nfs_info *nfs_infop;
#         struct nfs_client *clp = nfss->nfs_client;
#         u32 version = clp->rpc_ops->version;
#         int local_flock, local_fcntl;
# 
#         seq_printf(m, ",vers=%u", version);
#         seq_printf(m, ",rsize=%u", nfss->rsize);
#         seq_printf(m, ",wsize=%u", nfss->wsize);
#         if (nfss->bsize != 0)
#                 seq_printf(m, ",bsize=%u", nfss->bsize);
#         seq_printf(m, ",namlen=%u", nfss->namelen);
#         if (nfss->acregmin != NFS_DEF_ACREGMIN*HZ || showdefaults)
#                 seq_printf(m, ",acregmin=%u", nfss->acregmin/HZ);
#         if (nfss->acregmax != NFS_DEF_ACREGMAX*HZ || showdefaults)
#                 seq_printf(m, ",acregmax=%u", nfss->acregmax/HZ);
#         if (nfss->acdirmin != NFS_DEF_ACDIRMIN*HZ || showdefaults)
#                 seq_printf(m, ",acdirmin=%u", nfss->acdirmin/HZ);
#         if (nfss->acdirmax != NFS_DEF_ACDIRMAX*HZ || showdefaults)
#                 seq_printf(m, ",acdirmax=%u", nfss->acdirmax/HZ);
#         for (nfs_infop = nfs_info; nfs_infop->flag; nfs_infop++) {
#                 if (nfss->flags & nfs_infop->flag)
#                         seq_puts(m, nfs_infop->str);
#                 else
#                         seq_puts(m, nfs_infop->nostr);
#         }
# 
#         seq_printf(m, ",proto=%s",
#                    rpc_peeraddr2str(nfss->client, RPC_DISPLAY_NETID));
#         if (version == 4) {
#                 if (nfss->port != NFS_PORT)
#                         seq_printf(m, ",port=%u", nfss->port);
#         } else
#                 if (nfss->port)
#                         seq_printf(m, ",port=%u", nfss->port);
# 
#         seq_printf(m, ",timeo=%lu", 10U * nfss->client->cl_timeout->to_initval / HZ);
#         seq_printf(m, ",retrans=%u", nfss->client->cl_timeout->to_retries);
#         seq_printf(m, ",sec=%s", nfs_pseudoflavour_to_name(nfss->client->cl_auth->au_flavor));
# 
#         if (version != 4)
#                 nfs_show_mountd_options(m, nfss, showdefaults);
#         else
#                 nfs_show_nfsv4_options(m, nfss, showdefaults);
# 
#         if (nfss->options & NFS_OPTION_FSCACHE)
#                 seq_printf(m, ",fsc");
# 
#         if (nfss->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG) {
#                 if (nfss->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)
#                         seq_printf(m, ",lookupcache=none");
#                 else
#                         seq_printf(m, ",lookupcache=pos");
#         }
# 
#         local_flock = nfss->flags & NFS_MOUNT_LOCAL_FLOCK;
#         local_fcntl = nfss->flags & NFS_MOUNT_LOCAL_FCNTL;
# 
#         if (!local_flock && !local_fcntl)
#                 seq_printf(m, ",local_lock=none");
#         else if (local_flock && local_fcntl)
#                 seq_printf(m, ",local_lock=all");
#         else if (local_flock)
#                 seq_printf(m, ",local_lock=flock");
#         else
#                 seq_printf(m, ",local_lock=posix");
# }
# 
# static void nfs_show_mountd_options(struct seq_file *m, struct nfs_server *nfss,
#                                     int showdefaults)
# {
#         struct sockaddr *sap = (struct sockaddr *)&nfss->mountd_address;
# 
#         if (nfss->flags & NFS_MOUNT_LEGACY_INTERFACE)
#                 return;
# 
#         switch (sap->sa_family) {
#         case AF_INET: {
#                 struct sockaddr_in *sin = (struct sockaddr_in *)sap;
#                 seq_printf(m, ",mountaddr=%pI4", &sin->sin_addr.s_addr);
#                 break;
#         }
#         case AF_INET6: {
#                 struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;
#                 seq_printf(m, ",mountaddr=%pI6c", &sin6->sin6_addr);
#                 break;
#         }
#         default:
#                 if (showdefaults)
#                         seq_printf(m, ",mountaddr=unspecified");
#         }
# 
#         if (nfss->mountd_version || showdefaults)
#                 seq_printf(m, ",mountvers=%u", nfss->mountd_version);
#         if ((nfss->mountd_port &&
#                 nfss->mountd_port != (unsigned short)NFS_UNSPEC_PORT) ||
#                 showdefaults)
#                 seq_printf(m, ",mountport=%u", nfss->mountd_port);
# 
#         nfs_show_mountd_netid(m, nfss, showdefaults);
# }
# 
# static void nfs_show_nfsv4_options(struct seq_file *m, struct nfs_server *nfss,
#                                     int showdefaults)
# {
#         struct nfs_client *clp = nfss->nfs_client;
# 
#         seq_printf(m, ",clientaddr=%s", clp->cl_ipaddr);
#         seq_printf(m, ",minorversion=%u", clp->cl_minorversion);
# }
# 
# static void nfs_show_mountd_netid(struct seq_file *m, struct nfs_server *nfss,
#                                   int showdefaults)
# {
#         struct sockaddr *sap = (struct sockaddr *) &nfss->mountd_address;
# 
#         seq_printf(m, ",mountproto=");
#         switch (sap->sa_family) {
#         case AF_INET:
#                 switch (nfss->mountd_protocol) {
#                 case IPPROTO_UDP:
#                         seq_printf(m, RPCBIND_NETID_UDP);
#                         break;
#                 case IPPROTO_TCP:
#                         seq_printf(m, RPCBIND_NETID_TCP);
#                         break;
#                 default:
#                         if (showdefaults)
#                                 seq_printf(m, "auto");
#                 }
#                 break;
#         case AF_INET6:
#                 switch (nfss->mountd_protocol) {
#                 case IPPROTO_UDP:
#                         seq_printf(m, RPCBIND_NETID_UDP6);
#                         break;
#                 case IPPROTO_TCP:
#                         seq_printf(m, RPCBIND_NETID_TCP6);
#                         break;
#                 default:
#                         if (showdefaults)
#                                 seq_printf(m, "auto");
#                 }
#                 break;
#         default:
#                 if (showdefaults)
#                         seq_printf(m, "auto");
#         }
# }
# 
# 
# 
# from: net/sunrpc/stats.c
# --------
#
# static void _print_name(struct seq_file *seq, unsigned int op,
#                         struct rpc_procinfo *procs)
# {
#         if (procs[op].p_name)
#                 seq_printf(seq, "\t%12s: ", procs[op].p_name);
#         else if (op == 0)
#                 seq_printf(seq, "\t        NULL: ");
#         else
#                 seq_printf(seq, "\t%12u: ", op);
# }
# 
# void rpc_print_iostats(struct seq_file *seq, struct rpc_clnt *clnt)
# {
#         struct rpc_iostats *stats = clnt->cl_metrics;
#         struct rpc_xprt *xprt = clnt->cl_xprt;
#         unsigned int op, maxproc = clnt->cl_maxproc;
# 
#         if (!stats)
#                 return;
# 
#         seq_printf(seq, "\tRPC iostats version: %s  ", RPC_IOSTATS_VERS);
#         seq_printf(seq, "p/v: %u/%u (%s)\n",
#                         clnt->cl_prog, clnt->cl_vers, clnt->cl_protname);
# 
#         if (xprt)
#                 xprt->ops->print_stats(xprt, seq);
# 
#         seq_printf(seq, "\tper-op statistics\n");
#         for (op = 0; op < maxproc; op++) {
#                 struct rpc_iostats *metrics = &stats[op];
#                 _print_name(seq, op, clnt->cl_procinfo);
#                 seq_printf(seq, "%lu %lu %lu %Lu %Lu %Lu %Lu %Lu\n",
#                                 metrics->om_ops,
#                                 metrics->om_ntrans,
#                                 metrics->om_timeouts,
#                                 metrics->om_bytes_sent,
#                                 metrics->om_bytes_recv,
#                                 ktime_to_ms(metrics->om_queue),
#                                 ktime_to_ms(metrics->om_rtt),
#                                 ktime_to_ms(metrics->om_execute));
#         }
# }
# 
# from: net/sunrpc/xprtsock.c
# --------
# 
# static void xs_local_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)
# {
#         long idle_time = 0;
# 
#         if (xprt_connected(xprt))
#                 idle_time = (long)(jiffies - xprt->last_used) / HZ;
# 
#         seq_printf(seq, "\txprt:\tlocal %lu %lu %lu %ld %lu %lu %lu "
#                         "%llu %llu\n",
#                         xprt->stat.bind_count,
#                         xprt->stat.connect_count,
#                         xprt->stat.connect_time,
#                         idle_time,
#                         xprt->stat.sends,
#                         xprt->stat.recvs,
#                         xprt->stat.bad_xids,
#                         xprt->stat.req_u,
#                         xprt->stat.bklog_u);
# }
# 
# static void xs_udp_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)
# {
#         struct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);
# 
#         seq_printf(seq, "\txprt:\tudp %u %lu %lu %lu %lu %Lu %Lu\n",
#                         transport->srcport,
#                         xprt->stat.bind_count,
#                         xprt->stat.sends,
#                         xprt->stat.recvs,
#                         xprt->stat.bad_xids,
#                         xprt->stat.req_u,
#                         xprt->stat.bklog_u);
# }
# 
# static void xs_tcp_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)
# {
#         struct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);
#         long idle_time = 0;
# 
#         if (xprt_connected(xprt))
#                 idle_time = (long)(jiffies - xprt->last_used) / HZ;
# 
#         seq_printf(seq, "\txprt:\ttcp %u %lu %lu %lu %ld %lu %lu %lu %Lu %Lu\n",
#                         transport->srcport,
#                         xprt->stat.bind_count,
#                         xprt->stat.connect_count,
#                         xprt->stat.connect_time,
#                         idle_time,
#                         xprt->stat.sends,
#                         xprt->stat.recvs,
#                         xprt->stat.bad_xids,
#                         xprt->stat.req_u,
#                         xprt->stat.bklog_u);
# }



--- File: /proc/self/smaps

source: fs/proc/task_mmu.c

Excerpts from that code:

# static int show_smap(struct seq_file *m, void *v)
# {
# ...text deleted...
# 
#         show_map_vma(m, vma);
# 
#         seq_printf(m,
#                    "Size:           %8lu kB\n"
#                    "Rss:            %8lu kB\n"
#                    "Pss:            %8lu kB\n"
#                    "Shared_Clean:   %8lu kB\n"
#                    "Shared_Dirty:   %8lu kB\n"
#                    "Private_Clean:  %8lu kB\n"
#                    "Private_Dirty:  %8lu kB\n"
#                    "Referenced:     %8lu kB\n"
#                    "Anonymous:      %8lu kB\n"
#                    "AnonHugePages:  %8lu kB\n"
#                    "Swap:           %8lu kB\n"
#                    "KernelPageSize: %8lu kB\n"
#                    "MMUPageSize:    %8lu kB\n"
#                    "Locked:         %8lu kB\n",
#                    (vma->vm_end - vma->vm_start) >> 10,
#                    mss.resident >> 10,
#                    (unsigned long)(mss.pss >> (10 + PSS_SHIFT)),
#                    mss.shared_clean  >> 10,
#                    mss.shared_dirty  >> 10,
#                    mss.private_clean >> 10,
#                    mss.private_dirty >> 10,
#                    mss.referenced >> 10,
#                    mss.anonymous >> 10,
#                    mss.anonymous_thp >> 10,
#                    mss.swap >> 10,
#                    vma_kernel_pagesize(vma) >> 10,
#                    vma_mmu_pagesize(vma) >> 10,
#                    (vma->vm_flags & VM_LOCKED) ?
#                         (unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);
# 
# ...text deleted...
# }
# 
# 
# static void show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
# {
# 
# ...text deleted...
# 
#         seq_printf(m, "%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu %n",
#                         start,
#                         end,
#                         flags & VM_READ ? 'r' : '-',
#                         flags & VM_WRITE ? 'w' : '-',
#                         flags & VM_EXEC ? 'x' : '-',
#                         flags & VM_MAYSHARE ? 's' : 'p',
#                         pgoff,
#                         MAJOR(dev), MINOR(dev), ino, &len);
# 
#         /*
#          * Print the dentry name for named mappings, and a
#          * special [heap] marker for the heap:
#          */
#         if (file) {
#                 pad_len_spaces(m, len);
#                 seq_path(m, &file->f_path, "\n");
#         } else {
#                 const char *name = arch_vma_name(vma);
#                 if (!name) {
#                         if (mm) {
#                                 if (vma->vm_start <= mm->brk &&
#                                                 vma->vm_end >= mm->start_brk) {
#                                         name = "[heap]";
#                                 } else if (vma->vm_start <= mm->start_stack &&
#                                            vma->vm_end >= mm->start_stack) {
#                                         name = "[stack]";
#                                 }
#                         } else {
#                                 name = "[vdso]";
#                         }
#                 }
#                 if (name) {
#                         pad_len_spaces(m, len);
#                         seq_puts(m, name);
#                 }
#         }
#         seq_putc(m, '\n');
# }


--- File: /proc/self/status

source: fs/proc/array.c
--and--
source: fs/proc/task_mmu.c
--and---
source: kernel/cpuset.c

Excerpts from that code:

# from: fs/proc/array.c
# ---------
#
# int proc_pid_status(struct seq_file *m, struct pid_namespace *ns,
# 			struct pid *pid, struct task_struct *task)
# {
# 	struct mm_struct *mm = get_task_mm(task);
# 
# 	task_name(m, task);
# 	task_state(m, ns, pid, task);
# 
# 	if (mm) {
# 		task_mem(m, mm);
# 		mmput(mm);
# 	}
# 	task_sig(m, task);
# 	task_cap(m, task);
# 	task_cpus_allowed(m, task);
# 	cpuset_task_status_allowed(m, task);
# 	task_context_switch_counts(m, task);
# 	return 0;
# }
# 
# 
# static inline void task_name(struct seq_file *m, struct task_struct *p)
# {
# 	int i;
# 	char *buf, *end;
# 	char *name;
# 	char tcomm[sizeof(p->comm)];
# 
# 	get_task_comm(tcomm, p);
# 
# 	seq_puts(m, "Name:\t");
# 	end = m->buf + m->size;
# 	buf = m->buf + m->count;
# 	name = tcomm;
# 	i = sizeof(tcomm);
# 	while (i && (buf < end)) {
# 		unsigned char c = *name;
# 		name++;
# 		i--;
# 		*buf = c;
# 		if (!c)
# 			break;
# 		if (c == '\\') {
# 			buf++;
# 			if (buf < end)
# 				*buf++ = c;
# 			continue;
# 		}
# 		if (c == '\n') {
# 			*buf++ = '\\';
# 			if (buf < end)
# 				*buf++ = 'n';
# 			continue;
# 		}
# 		buf++;
# 	}
# 	m->count = buf - m->buf;
# 	seq_putc(m, '\n');
# }
# 
# 
# 
# static inline void task_state(struct seq_file *m, struct pid_namespace *ns,
# 				struct pid *pid, struct task_struct *p)
# {
# 	struct group_info *group_info;
# 	int g;
# 	struct fdtable *fdt = NULL;
# 	const struct cred *cred;
# 	pid_t ppid, tpid;
# 
# 	rcu_read_lock();
# 	ppid = pid_alive(p) ?
# 		task_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;
# 	tpid = 0;
# 	if (pid_alive(p)) {
# 		struct task_struct *tracer = ptrace_parent(p);
# 		if (tracer)
# 			tpid = task_pid_nr_ns(tracer, ns);
# 	}
# 	cred = get_task_cred(p);
# 	seq_printf(m,
# 		"State:\t%s\n"
# 		"Tgid:\t%d\n"
# 		"Pid:\t%d\n"
# 		"PPid:\t%d\n"
# 		"TracerPid:\t%d\n"
# 		"Uid:\t%d\t%d\t%d\t%d\n"
# 		"Gid:\t%d\t%d\t%d\t%d\n",
# 		get_task_state(p),
# 		task_tgid_nr_ns(p, ns),
# 		pid_nr_ns(pid, ns),
# 		ppid, tpid,
# 		cred->uid, cred->euid, cred->suid, cred->fsuid,
# 		cred->gid, cred->egid, cred->sgid, cred->fsgid);
# 
# 	task_lock(p);
# 	if (p->files)
# 		fdt = files_fdtable(p->files);
# 	seq_printf(m,
# 		"FDSize:\t%d\n"
# 		"Groups:\t",
# 		fdt ? fdt->max_fds : 0);
# 	rcu_read_unlock();
# 
# 	group_info = cred->group_info;
# 	task_unlock(p);
# 
# 	for (g = 0; g < min(group_info->ngroups, NGROUPS_SMALL); g++)
# 		seq_printf(m, "%d ", GROUP_AT(group_info, g));
# 	put_cred(cred);
# 
# 	seq_putc(m, '\n');
# }
# 
# static inline void task_sig(struct seq_file *m, struct task_struct *p)
# {
# 	unsigned long flags;
# 	sigset_t pending, shpending, blocked, ignored, caught;
# 	int num_threads = 0;
# 	unsigned long qsize = 0;
# 	unsigned long qlim = 0;
# 
# 	sigemptyset(&pending);
# 	sigemptyset(&shpending);
# 	sigemptyset(&blocked);
# 	sigemptyset(&ignored);
# 	sigemptyset(&caught);
# 
# 	if (lock_task_sighand(p, &flags)) {
# 		pending = p->pending.signal;
# 		shpending = p->signal->shared_pending.signal;
# 		blocked = p->blocked;
# 		collect_sigign_sigcatch(p, &ignored, &caught);
# 		num_threads = get_nr_threads(p);
# 		rcu_read_lock();  /* FIXME: is this correct? */
# 		qsize = atomic_read(&__task_cred(p)->user->sigpending);
# 		rcu_read_unlock();
# 		qlim = task_rlimit(p, RLIMIT_SIGPENDING);
# 		unlock_task_sighand(p, &flags);
# 	}
# 
# 	seq_printf(m, "Threads:\t%d\n", num_threads);
# 	seq_printf(m, "SigQ:\t%lu/%lu\n", qsize, qlim);
# 
# 	/* render them all */
# 	render_sigset_t(m, "SigPnd:\t", &pending);
# 	render_sigset_t(m, "ShdPnd:\t", &shpending);
# 	render_sigset_t(m, "SigBlk:\t", &blocked);
# 	render_sigset_t(m, "SigIgn:\t", &ignored);
# 	render_sigset_t(m, "SigCgt:\t", &caught);
# }
# 
# 
# static inline void task_cap(struct seq_file *m, struct task_struct *p)
# {
# 	const struct cred *cred;
# 	kernel_cap_t cap_inheritable, cap_permitted, cap_effective, cap_bset;
# 
# 	rcu_read_lock();
# 	cred = __task_cred(p);
# 	cap_inheritable	= cred->cap_inheritable;
# 	cap_permitted	= cred->cap_permitted;
# 	cap_effective	= cred->cap_effective;
# 	cap_bset	= cred->cap_bset;
# 	rcu_read_unlock();
# 
# 	render_cap_t(m, "CapInh:\t", &cap_inheritable);
# 	render_cap_t(m, "CapPrm:\t", &cap_permitted);
# 	render_cap_t(m, "CapEff:\t", &cap_effective);
# 	render_cap_t(m, "CapBnd:\t", &cap_bset);
# }
# 
# 
# static void task_cpus_allowed(struct seq_file *m, struct task_struct *task)
# {
# 	seq_puts(m, "Cpus_allowed:\t");
# 	seq_cpumask(m, &task->cpus_allowed);
# 	seq_putc(m, '\n');
# 	seq_puts(m, "Cpus_allowed_list:\t");
# 	seq_cpumask_list(m, &task->cpus_allowed);
# 	seq_putc(m, '\n');
# }
# 
# 
# static inline void task_context_switch_counts(struct seq_file *m,
# 						struct task_struct *p)
# {
# 	seq_printf(m,	"voluntary_ctxt_switches:\t%lu\n"
# 			"nonvoluntary_ctxt_switches:\t%lu\n",
# 			p->nvcsw,
# 			p->nivcsw);
# }


# from: fs/proc/task_mmu.c
# ---------
#
# void task_mem(struct seq_file *m, struct mm_struct *mm)
# {
# 	unsigned long data, text, lib, swap;
# 	unsigned long hiwater_vm, total_vm, hiwater_rss, total_rss;
# 
# 	/*
# 	 * Note: to minimize their overhead, mm maintains hiwater_vm and
# 	 * hiwater_rss only when about to *lower* total_vm or rss.  Any
# 	 * collector of these hiwater stats must therefore get total_vm
# 	 * and rss too, which will usually be the higher.  Barriers? not
# 	 * worth the effort, such snapshots can always be inconsistent.
# 	 */
# 	hiwater_vm = total_vm = mm->total_vm;
# 	if (hiwater_vm < mm->hiwater_vm)
# 		hiwater_vm = mm->hiwater_vm;
# 	hiwater_rss = total_rss = get_mm_rss(mm);
# 	if (hiwater_rss < mm->hiwater_rss)
# 		hiwater_rss = mm->hiwater_rss;
# 
# 	data = mm->total_vm - mm->shared_vm - mm->stack_vm;
# 	text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK)) >> 10;
# 	lib = (mm->exec_vm << (PAGE_SHIFT-10)) - text;
# 	swap = get_mm_counter(mm, MM_SWAPENTS);
# 	seq_printf(m,
# 		"VmPeak:\t%8lu kB\n"
# 		"VmSize:\t%8lu kB\n"
# 		"VmLck:\t%8lu kB\n"
# 		"VmPin:\t%8lu kB\n"
# 		"VmHWM:\t%8lu kB\n"
# 		"VmRSS:\t%8lu kB\n"
# 		"VmData:\t%8lu kB\n"
# 		"VmStk:\t%8lu kB\n"
# 		"VmExe:\t%8lu kB\n"
# 		"VmLib:\t%8lu kB\n"
# 		"VmPTE:\t%8lu kB\n"
# 		"VmSwap:\t%8lu kB\n",
# 		hiwater_vm << (PAGE_SHIFT-10),
# 		(total_vm - mm->reserved_vm) << (PAGE_SHIFT-10),
# 		mm->locked_vm << (PAGE_SHIFT-10),
# 		mm->pinned_vm << (PAGE_SHIFT-10),
# 		hiwater_rss << (PAGE_SHIFT-10),
# 		total_rss << (PAGE_SHIFT-10),
# 		data << (PAGE_SHIFT-10),
# 		mm->stack_vm << (PAGE_SHIFT-10), text, lib,
# 		(PTRS_PER_PTE*sizeof(pte_t)*mm->nr_ptes) >> 10,
# 		swap << (PAGE_SHIFT-10));
# }

# from: kernel/cpuset.c
# ---------
#
# void cpuset_task_status_allowed(struct seq_file *m, struct task_struct *task)
# {
# 	seq_printf(m, "Mems_allowed:\t");
# 	seq_nodemask(m, &task->mems_allowed);
# 	seq_printf(m, "\n");
# 	seq_printf(m, "Mems_allowed_list:\t");
# 	seq_nodemask_list(m, &task->mems_allowed);
# 	seq_printf(m, "\n");
# }
