#
# This document contains portions of Linux kernel source code, included
# to demonstrate how various "/proc" files are generated.  That code,
# while not intended to be compiled/used as presented here, is distributed
# according to the terms of the following license.
#
# (C) 2014 Jim Jones <cnamejj@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

The module ProcRootHandlers.py contains code snippets from kernel source
as comments in each "handler" class where the relevant code sample is
less than 50 lines.  For /proc files where the amount of source code
involved in generating the contents of the file is longer, the sample
code is document here instead.


--- File: /proc/self/mountinfo

source: fs/namespace.c

Excerpts from that code:

#        seq_printf(m, "%i %i %u:%u ", mnt->mnt_id, mnt->mnt_parent->mnt_id,
#                   MAJOR(sb->s_dev), MINOR(sb->s_dev));
#        if (sb->s_op->show_path)
#                err = sb->s_op->show_path(m, mnt);
#        else
#                seq_dentry(m, mnt->mnt_root, " \t\n\\");
#        if (err)
#                goto out;
#        seq_putc(m, ' ');
#
#        /* mountpoints outside of chroot jail will give SEQ_SKIP on this */
#        err = seq_path_root(m, &mnt_path, &root, " \t\n\\");
#        if (err)
#                goto out;
#
#        seq_puts(m, mnt->mnt_flags & MNT_READONLY ? " ro" : " rw");
#        show_mnt_opts(m, mnt);
#
#        /* Tagged fields ("foo:X" or "bar") */
#        if (IS_MNT_SHARED(mnt))
#                seq_printf(m, " shared:%i", mnt->mnt_group_id);
#        if (IS_MNT_SLAVE(mnt)) {
#                int master = mnt->mnt_master->mnt_group_id;
#                int dom = get_dominating_id(mnt, &p->root);
#                seq_printf(m, " master:%i", master);
#                if (dom && dom != master)
#                        seq_printf(m, " propagate_from:%i", dom);
#        }
#        if (IS_MNT_UNBINDABLE(mnt))
#                seq_puts(m, " unbindable");
#
#        /* Filesystem specific data */
#        seq_puts(m, " - ");
#        show_type(m, sb);
#        seq_putc(m, ' ');
#        if (sb->s_op->show_devname)
#                err = sb->s_op->show_devname(m, mnt);
#        else
#                mangle(m, mnt->mnt_devname ? mnt->mnt_devname : "none");
#        if (err)
#                goto out;
#        seq_puts(m, sb->s_flags & MS_RDONLY ? " ro" : " rw");
#        err = show_sb_opts(m, sb);
#        if (err)
#                goto out;
#        if (sb->s_op->show_options)
#                err = sb->s_op->show_options(m, mnt);
#        seq_putc(m, '\n');
#
# --and--
#
# static void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)
# {
#        static const struct proc_fs_info mnt_info[] = {
#                { MNT_NOSUID, ",nosuid" },
#                { MNT_NODEV, ",nodev" },
#                { MNT_NOEXEC, ",noexec" },
#                { MNT_NOATIME, ",noatime" },
#                { MNT_NODIRATIME, ",nodiratime" },
#                { MNT_RELATIME, ",relatime" },
#                { 0, NULL }
#        };
#        const struct proc_fs_info *fs_infop;
#
#        for (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {
#                if (mnt->mnt_flags & fs_infop->flag)
#                        seq_puts(m, fs_infop->str);
#        }
# }




--- File: /proc/self/mountstats

source: fs/namespace.c
--and--
source: fs/nfs/super.c
--and--
source: net/sunrpc/xprtsock.c
--and--
source: net/sunrpc/stats.c

Excerpts from that code:

# from: fs/namespace.c
# --------
# 
# static int show_vfsstat(struct seq_file *m, void *v)
# {
#         struct vfsmount *mnt = list_entry(v, struct vfsmount, mnt_list);
#         struct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };
#         int err = 0;
# 
#         /* device */
#         if (mnt->mnt_sb->s_op->show_devname) {
#                 seq_puts(m, "device ");
#                 err = mnt->mnt_sb->s_op->show_devname(m, mnt);
#         } else {
#                 if (mnt->mnt_devname) {
#                         seq_puts(m, "device ");
#                         mangle(m, mnt->mnt_devname);
#                 } else
#                         seq_puts(m, "no device");
#         }
# 
#         /* mount point */
#         seq_puts(m, " mounted on ");
#         seq_path(m, &mnt_path, " \t\n\\");
#         seq_putc(m, ' ');
# 
#         /* file system type */
#         seq_puts(m, "with fstype ");
#         show_type(m, mnt->mnt_sb);
# 
#         /* optional statistics */
#         if (mnt->mnt_sb->s_op->show_stats) {
#                 seq_putc(m, ' ');
#                 if (!err)
#                         err = mnt->mnt_sb->s_op->show_stats(m, mnt);
#         }
# 
#         seq_putc(m, '\n');
#         return err;
# }
# 
# 
# from: fs/nfs/super.c
# --------
# 
# static int nfs_show_stats(struct seq_file *m, struct vfsmount *mnt)
# {
#         int i, cpu;
#         struct nfs_server *nfss = NFS_SB(mnt->mnt_sb);
#         struct rpc_auth *auth = nfss->client->cl_auth;
#         struct nfs_iostats totals = { };
# 
#         seq_printf(m, "statvers=%s", NFS_IOSTAT_VERS);
# 
#         /*
#          * Display all mount option settings
#          */
#         seq_printf(m, "\n\topts:\t");
#         seq_puts(m, mnt->mnt_sb->s_flags & MS_RDONLY ? "ro" : "rw");
#         seq_puts(m, mnt->mnt_sb->s_flags & MS_SYNCHRONOUS ? ",sync" : "");
#         seq_puts(m, mnt->mnt_sb->s_flags & MS_NOATIME ? ",noatime" : "");
#         seq_puts(m, mnt->mnt_sb->s_flags & MS_NODIRATIME ? ",nodiratime" : "");
#         nfs_show_mount_options(m, nfss, 1);
# 
#         seq_printf(m, "\n\tage:\t%lu", (jiffies - nfss->mount_time) / HZ);
# 
#         seq_printf(m, "\n\tcaps:\t");
#         seq_printf(m, "caps=0x%x", nfss->caps);
#         seq_printf(m, ",wtmult=%u", nfss->wtmult);
#         seq_printf(m, ",dtsize=%u", nfss->dtsize);
#         seq_printf(m, ",bsize=%u", nfss->bsize);
#         seq_printf(m, ",namlen=%u", nfss->namelen);
# 
# #ifdef CONFIG_NFS_V4
#         if (nfss->nfs_client->rpc_ops->version == 4) {
#                 seq_printf(m, "\n\tnfsv4:\t");
#                 seq_printf(m, "bm0=0x%x", nfss->attr_bitmask[0]);
#                 seq_printf(m, ",bm1=0x%x", nfss->attr_bitmask[1]);
#                 seq_printf(m, ",acl=0x%x", nfss->acl_bitmask);
#                 show_sessions(m, nfss);
#                 show_pnfs(m, nfss);
#         }
# #endif
# 
#         /*
#          * Display security flavor in effect for this mount
#          */
#         seq_printf(m, "\n\tsec:\tflavor=%u", auth->au_ops->au_flavor);
#         if (auth->au_flavor)
#                 seq_printf(m, ",pseudoflavor=%u", auth->au_flavor);
# 
#         /*
#          * Display superblock I/O counters
#          */
#         for_each_possible_cpu(cpu) {
#                 struct nfs_iostats *stats;
# 
#                 preempt_disable();
#                 stats = per_cpu_ptr(nfss->io_stats, cpu);
# 
#                 for (i = 0; i < __NFSIOS_COUNTSMAX; i++)
#                         totals.events[i] += stats->events[i];
#                 for (i = 0; i < __NFSIOS_BYTESMAX; i++)
#                         totals.bytes[i] += stats->bytes[i];
# #ifdef CONFIG_NFS_FSCACHE
#                 for (i = 0; i < __NFSIOS_FSCACHEMAX; i++)
#                         totals.fscache[i] += stats->fscache[i];
# #endif
# 
#                 preempt_enable();
#         }
# 
#         seq_printf(m, "\n\tevents:\t");
#         for (i = 0; i < __NFSIOS_COUNTSMAX; i++)
#                 seq_printf(m, "%lu ", totals.events[i]);
#         seq_printf(m, "\n\tbytes:\t");
#         for (i = 0; i < __NFSIOS_BYTESMAX; i++)
#                 seq_printf(m, "%Lu ", totals.bytes[i]);
# #ifdef CONFIG_NFS_FSCACHE
#         if (nfss->options & NFS_OPTION_FSCACHE) {
#                 seq_printf(m, "\n\tfsc:\t");
#                 for (i = 0; i < __NFSIOS_FSCACHEMAX; i++)
#                         seq_printf(m, "%Lu ", totals.bytes[i]);
#         }
# #endif
#         seq_printf(m, "\n");
# 
#         rpc_print_iostats(m, nfss->client);
# 
#         return 0;
# }
# 
# static void show_sessions(struct seq_file *m, struct nfs_server *server)
# {
#         if (nfs4_has_session(server->nfs_client))
#                 seq_printf(m, ",sessions");
# }
# 
# static void show_pnfs(struct seq_file *m, struct nfs_server *server)
# {
#         seq_printf(m, ",pnfs=");
#         if (server->pnfs_curr_ld)
#                 seq_printf(m, "%s", server->pnfs_curr_ld->name);
#         else
#                 seq_printf(m, "not configured");
# }
# 
# 
# static void nfs_show_mount_options(struct seq_file *m, struct nfs_server *nfss,
#                                    int showdefaults)
# {
#         static const struct proc_nfs_info {
#                 int flag;
#                 const char *str;
#                 const char *nostr;
#         } nfs_info[] = {
#                 { NFS_MOUNT_SOFT, ",soft", ",hard" },
#                 { NFS_MOUNT_POSIX, ",posix", "" },
#                 { NFS_MOUNT_NOCTO, ",nocto", "" },
#                 { NFS_MOUNT_NOAC, ",noac", "" },
#                 { NFS_MOUNT_NONLM, ",nolock", "" },
#                 { NFS_MOUNT_NOACL, ",noacl", "" },
#                 { NFS_MOUNT_NORDIRPLUS, ",nordirplus", "" },
#                 { NFS_MOUNT_UNSHARED, ",nosharecache", "" },
#                 { NFS_MOUNT_NORESVPORT, ",noresvport", "" },
#                 { 0, NULL, NULL }
#         };
#         const struct proc_nfs_info *nfs_infop;
#         struct nfs_client *clp = nfss->nfs_client;
#         u32 version = clp->rpc_ops->version;
#         int local_flock, local_fcntl;
# 
#         seq_printf(m, ",vers=%u", version);
#         seq_printf(m, ",rsize=%u", nfss->rsize);
#         seq_printf(m, ",wsize=%u", nfss->wsize);
#         if (nfss->bsize != 0)
#                 seq_printf(m, ",bsize=%u", nfss->bsize);
#         seq_printf(m, ",namlen=%u", nfss->namelen);
#         if (nfss->acregmin != NFS_DEF_ACREGMIN*HZ || showdefaults)
#                 seq_printf(m, ",acregmin=%u", nfss->acregmin/HZ);
#         if (nfss->acregmax != NFS_DEF_ACREGMAX*HZ || showdefaults)
#                 seq_printf(m, ",acregmax=%u", nfss->acregmax/HZ);
#         if (nfss->acdirmin != NFS_DEF_ACDIRMIN*HZ || showdefaults)
#                 seq_printf(m, ",acdirmin=%u", nfss->acdirmin/HZ);
#         if (nfss->acdirmax != NFS_DEF_ACDIRMAX*HZ || showdefaults)
#                 seq_printf(m, ",acdirmax=%u", nfss->acdirmax/HZ);
#         for (nfs_infop = nfs_info; nfs_infop->flag; nfs_infop++) {
#                 if (nfss->flags & nfs_infop->flag)
#                         seq_puts(m, nfs_infop->str);
#                 else
#                         seq_puts(m, nfs_infop->nostr);
#         }
# 
#         seq_printf(m, ",proto=%s",
#                    rpc_peeraddr2str(nfss->client, RPC_DISPLAY_NETID));
#         if (version == 4) {
#                 if (nfss->port != NFS_PORT)
#                         seq_printf(m, ",port=%u", nfss->port);
#         } else
#                 if (nfss->port)
#                         seq_printf(m, ",port=%u", nfss->port);
# 
#         seq_printf(m, ",timeo=%lu", 10U * nfss->client->cl_timeout->to_initval / HZ);
#         seq_printf(m, ",retrans=%u", nfss->client->cl_timeout->to_retries);
#         seq_printf(m, ",sec=%s", nfs_pseudoflavour_to_name(nfss->client->cl_auth->au_flavor));
# 
#         if (version != 4)
#                 nfs_show_mountd_options(m, nfss, showdefaults);
#         else
#                 nfs_show_nfsv4_options(m, nfss, showdefaults);
# 
#         if (nfss->options & NFS_OPTION_FSCACHE)
#                 seq_printf(m, ",fsc");
# 
#         if (nfss->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG) {
#                 if (nfss->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)
#                         seq_printf(m, ",lookupcache=none");
#                 else
#                         seq_printf(m, ",lookupcache=pos");
#         }
# 
#         local_flock = nfss->flags & NFS_MOUNT_LOCAL_FLOCK;
#         local_fcntl = nfss->flags & NFS_MOUNT_LOCAL_FCNTL;
# 
#         if (!local_flock && !local_fcntl)
#                 seq_printf(m, ",local_lock=none");
#         else if (local_flock && local_fcntl)
#                 seq_printf(m, ",local_lock=all");
#         else if (local_flock)
#                 seq_printf(m, ",local_lock=flock");
#         else
#                 seq_printf(m, ",local_lock=posix");
# }
# 
# static void nfs_show_mountd_options(struct seq_file *m, struct nfs_server *nfss,
#                                     int showdefaults)
# {
#         struct sockaddr *sap = (struct sockaddr *)&nfss->mountd_address;
# 
#         if (nfss->flags & NFS_MOUNT_LEGACY_INTERFACE)
#                 return;
# 
#         switch (sap->sa_family) {
#         case AF_INET: {
#                 struct sockaddr_in *sin = (struct sockaddr_in *)sap;
#                 seq_printf(m, ",mountaddr=%pI4", &sin->sin_addr.s_addr);
#                 break;
#         }
#         case AF_INET6: {
#                 struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;
#                 seq_printf(m, ",mountaddr=%pI6c", &sin6->sin6_addr);
#                 break;
#         }
#         default:
#                 if (showdefaults)
#                         seq_printf(m, ",mountaddr=unspecified");
#         }
# 
#         if (nfss->mountd_version || showdefaults)
#                 seq_printf(m, ",mountvers=%u", nfss->mountd_version);
#         if ((nfss->mountd_port &&
#                 nfss->mountd_port != (unsigned short)NFS_UNSPEC_PORT) ||
#                 showdefaults)
#                 seq_printf(m, ",mountport=%u", nfss->mountd_port);
# 
#         nfs_show_mountd_netid(m, nfss, showdefaults);
# }
# 
# static void nfs_show_nfsv4_options(struct seq_file *m, struct nfs_server *nfss,
#                                     int showdefaults)
# {
#         struct nfs_client *clp = nfss->nfs_client;
# 
#         seq_printf(m, ",clientaddr=%s", clp->cl_ipaddr);
#         seq_printf(m, ",minorversion=%u", clp->cl_minorversion);
# }
# 
# static void nfs_show_mountd_netid(struct seq_file *m, struct nfs_server *nfss,
#                                   int showdefaults)
# {
#         struct sockaddr *sap = (struct sockaddr *) &nfss->mountd_address;
# 
#         seq_printf(m, ",mountproto=");
#         switch (sap->sa_family) {
#         case AF_INET:
#                 switch (nfss->mountd_protocol) {
#                 case IPPROTO_UDP:
#                         seq_printf(m, RPCBIND_NETID_UDP);
#                         break;
#                 case IPPROTO_TCP:
#                         seq_printf(m, RPCBIND_NETID_TCP);
#                         break;
#                 default:
#                         if (showdefaults)
#                                 seq_printf(m, "auto");
#                 }
#                 break;
#         case AF_INET6:
#                 switch (nfss->mountd_protocol) {
#                 case IPPROTO_UDP:
#                         seq_printf(m, RPCBIND_NETID_UDP6);
#                         break;
#                 case IPPROTO_TCP:
#                         seq_printf(m, RPCBIND_NETID_TCP6);
#                         break;
#                 default:
#                         if (showdefaults)
#                                 seq_printf(m, "auto");
#                 }
#                 break;
#         default:
#                 if (showdefaults)
#                         seq_printf(m, "auto");
#         }
# }
# 
# 
# 
# from: net/sunrpc/stats.c
# --------
#
# static void _print_name(struct seq_file *seq, unsigned int op,
#                         struct rpc_procinfo *procs)
# {
#         if (procs[op].p_name)
#                 seq_printf(seq, "\t%12s: ", procs[op].p_name);
#         else if (op == 0)
#                 seq_printf(seq, "\t        NULL: ");
#         else
#                 seq_printf(seq, "\t%12u: ", op);
# }
# 
# void rpc_print_iostats(struct seq_file *seq, struct rpc_clnt *clnt)
# {
#         struct rpc_iostats *stats = clnt->cl_metrics;
#         struct rpc_xprt *xprt = clnt->cl_xprt;
#         unsigned int op, maxproc = clnt->cl_maxproc;
# 
#         if (!stats)
#                 return;
# 
#         seq_printf(seq, "\tRPC iostats version: %s  ", RPC_IOSTATS_VERS);
#         seq_printf(seq, "p/v: %u/%u (%s)\n",
#                         clnt->cl_prog, clnt->cl_vers, clnt->cl_protname);
# 
#         if (xprt)
#                 xprt->ops->print_stats(xprt, seq);
# 
#         seq_printf(seq, "\tper-op statistics\n");
#         for (op = 0; op < maxproc; op++) {
#                 struct rpc_iostats *metrics = &stats[op];
#                 _print_name(seq, op, clnt->cl_procinfo);
#                 seq_printf(seq, "%lu %lu %lu %Lu %Lu %Lu %Lu %Lu\n",
#                                 metrics->om_ops,
#                                 metrics->om_ntrans,
#                                 metrics->om_timeouts,
#                                 metrics->om_bytes_sent,
#                                 metrics->om_bytes_recv,
#                                 ktime_to_ms(metrics->om_queue),
#                                 ktime_to_ms(metrics->om_rtt),
#                                 ktime_to_ms(metrics->om_execute));
#         }
# }
# 
# from: net/sunrpc/xprtsock.c
# --------
# 
# static void xs_local_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)
# {
#         long idle_time = 0;
# 
#         if (xprt_connected(xprt))
#                 idle_time = (long)(jiffies - xprt->last_used) / HZ;
# 
#         seq_printf(seq, "\txprt:\tlocal %lu %lu %lu %ld %lu %lu %lu "
#                         "%llu %llu\n",
#                         xprt->stat.bind_count,
#                         xprt->stat.connect_count,
#                         xprt->stat.connect_time,
#                         idle_time,
#                         xprt->stat.sends,
#                         xprt->stat.recvs,
#                         xprt->stat.bad_xids,
#                         xprt->stat.req_u,
#                         xprt->stat.bklog_u);
# }
# 
# static void xs_udp_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)
# {
#         struct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);
# 
#         seq_printf(seq, "\txprt:\tudp %u %lu %lu %lu %lu %Lu %Lu\n",
#                         transport->srcport,
#                         xprt->stat.bind_count,
#                         xprt->stat.sends,
#                         xprt->stat.recvs,
#                         xprt->stat.bad_xids,
#                         xprt->stat.req_u,
#                         xprt->stat.bklog_u);
# }
# 
# static void xs_tcp_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)
# {
#         struct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);
#         long idle_time = 0;
# 
#         if (xprt_connected(xprt))
#                 idle_time = (long)(jiffies - xprt->last_used) / HZ;
# 
#         seq_printf(seq, "\txprt:\ttcp %u %lu %lu %lu %ld %lu %lu %lu %Lu %Lu\n",
#                         transport->srcport,
#                         xprt->stat.bind_count,
#                         xprt->stat.connect_count,
#                         xprt->stat.connect_time,
#                         idle_time,
#                         xprt->stat.sends,
#                         xprt->stat.recvs,
#                         xprt->stat.bad_xids,
#                         xprt->stat.req_u,
#                         xprt->stat.bklog_u);
# }



--- File: /proc/self/smaps

source: fs/proc/task_mmu.c

Excerpts from that code:

# static int show_smap(struct seq_file *m, void *v)
# {
# ...text deleted...
# 
#         show_map_vma(m, vma);
# 
#         seq_printf(m,
#                    "Size:           %8lu kB\n"
#                    "Rss:            %8lu kB\n"
#                    "Pss:            %8lu kB\n"
#                    "Shared_Clean:   %8lu kB\n"
#                    "Shared_Dirty:   %8lu kB\n"
#                    "Private_Clean:  %8lu kB\n"
#                    "Private_Dirty:  %8lu kB\n"
#                    "Referenced:     %8lu kB\n"
#                    "Anonymous:      %8lu kB\n"
#                    "AnonHugePages:  %8lu kB\n"
#                    "Swap:           %8lu kB\n"
#                    "KernelPageSize: %8lu kB\n"
#                    "MMUPageSize:    %8lu kB\n"
#                    "Locked:         %8lu kB\n",
#                    (vma->vm_end - vma->vm_start) >> 10,
#                    mss.resident >> 10,
#                    (unsigned long)(mss.pss >> (10 + PSS_SHIFT)),
#                    mss.shared_clean  >> 10,
#                    mss.shared_dirty  >> 10,
#                    mss.private_clean >> 10,
#                    mss.private_dirty >> 10,
#                    mss.referenced >> 10,
#                    mss.anonymous >> 10,
#                    mss.anonymous_thp >> 10,
#                    mss.swap >> 10,
#                    vma_kernel_pagesize(vma) >> 10,
#                    vma_mmu_pagesize(vma) >> 10,
#                    (vma->vm_flags & VM_LOCKED) ?
#                         (unsigned long)(mss.pss >> (10 + PSS_SHIFT)) : 0);
# 
# ...text deleted...
# }
# 
# 
# static void show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
# {
# 
# ...text deleted...
# 
#         seq_printf(m, "%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu %n",
#                         start,
#                         end,
#                         flags & VM_READ ? 'r' : '-',
#                         flags & VM_WRITE ? 'w' : '-',
#                         flags & VM_EXEC ? 'x' : '-',
#                         flags & VM_MAYSHARE ? 's' : 'p',
#                         pgoff,
#                         MAJOR(dev), MINOR(dev), ino, &len);
# 
#         /*
#          * Print the dentry name for named mappings, and a
#          * special [heap] marker for the heap:
#          */
#         if (file) {
#                 pad_len_spaces(m, len);
#                 seq_path(m, &file->f_path, "\n");
#         } else {
#                 const char *name = arch_vma_name(vma);
#                 if (!name) {
#                         if (mm) {
#                                 if (vma->vm_start <= mm->brk &&
#                                                 vma->vm_end >= mm->start_brk) {
#                                         name = "[heap]";
#                                 } else if (vma->vm_start <= mm->start_stack &&
#                                            vma->vm_end >= mm->start_stack) {
#                                         name = "[stack]";
#                                 }
#                         } else {
#                                 name = "[vdso]";
#                         }
#                 }
#                 if (name) {
#                         pad_len_spaces(m, len);
#                         seq_puts(m, name);
#                 }
#         }
#         seq_putc(m, '\n');
# }


--- File: /proc/self/status

source: fs/proc/array.c
--and--
source: fs/proc/task_mmu.c
--and---
source: kernel/cpuset.c

Excerpts from that code:

# from: fs/proc/array.c
# ---------
#
# int proc_pid_status(struct seq_file *m, struct pid_namespace *ns,
# 			struct pid *pid, struct task_struct *task)
# {
# 	struct mm_struct *mm = get_task_mm(task);
# 
# 	task_name(m, task);
# 	task_state(m, ns, pid, task);
# 
# 	if (mm) {
# 		task_mem(m, mm);
# 		mmput(mm);
# 	}
# 	task_sig(m, task);
# 	task_cap(m, task);
# 	task_cpus_allowed(m, task);
# 	cpuset_task_status_allowed(m, task);
# 	task_context_switch_counts(m, task);
# 	return 0;
# }
# 
# 
# static inline void task_name(struct seq_file *m, struct task_struct *p)
# {
# 	int i;
# 	char *buf, *end;
# 	char *name;
# 	char tcomm[sizeof(p->comm)];
# 
# 	get_task_comm(tcomm, p);
# 
# 	seq_puts(m, "Name:\t");
# 	end = m->buf + m->size;
# 	buf = m->buf + m->count;
# 	name = tcomm;
# 	i = sizeof(tcomm);
# 	while (i && (buf < end)) {
# 		unsigned char c = *name;
# 		name++;
# 		i--;
# 		*buf = c;
# 		if (!c)
# 			break;
# 		if (c == '\\') {
# 			buf++;
# 			if (buf < end)
# 				*buf++ = c;
# 			continue;
# 		}
# 		if (c == '\n') {
# 			*buf++ = '\\';
# 			if (buf < end)
# 				*buf++ = 'n';
# 			continue;
# 		}
# 		buf++;
# 	}
# 	m->count = buf - m->buf;
# 	seq_putc(m, '\n');
# }
# 
# 
# 
# static inline void task_state(struct seq_file *m, struct pid_namespace *ns,
# 				struct pid *pid, struct task_struct *p)
# {
# 	struct group_info *group_info;
# 	int g;
# 	struct fdtable *fdt = NULL;
# 	const struct cred *cred;
# 	pid_t ppid, tpid;
# 
# 	rcu_read_lock();
# 	ppid = pid_alive(p) ?
# 		task_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;
# 	tpid = 0;
# 	if (pid_alive(p)) {
# 		struct task_struct *tracer = ptrace_parent(p);
# 		if (tracer)
# 			tpid = task_pid_nr_ns(tracer, ns);
# 	}
# 	cred = get_task_cred(p);
# 	seq_printf(m,
# 		"State:\t%s\n"
# 		"Tgid:\t%d\n"
# 		"Pid:\t%d\n"
# 		"PPid:\t%d\n"
# 		"TracerPid:\t%d\n"
# 		"Uid:\t%d\t%d\t%d\t%d\n"
# 		"Gid:\t%d\t%d\t%d\t%d\n",
# 		get_task_state(p),
# 		task_tgid_nr_ns(p, ns),
# 		pid_nr_ns(pid, ns),
# 		ppid, tpid,
# 		cred->uid, cred->euid, cred->suid, cred->fsuid,
# 		cred->gid, cred->egid, cred->sgid, cred->fsgid);
# 
# 	task_lock(p);
# 	if (p->files)
# 		fdt = files_fdtable(p->files);
# 	seq_printf(m,
# 		"FDSize:\t%d\n"
# 		"Groups:\t",
# 		fdt ? fdt->max_fds : 0);
# 	rcu_read_unlock();
# 
# 	group_info = cred->group_info;
# 	task_unlock(p);
# 
# 	for (g = 0; g < min(group_info->ngroups, NGROUPS_SMALL); g++)
# 		seq_printf(m, "%d ", GROUP_AT(group_info, g));
# 	put_cred(cred);
# 
# 	seq_putc(m, '\n');
# }
# 
# static inline void task_sig(struct seq_file *m, struct task_struct *p)
# {
# 	unsigned long flags;
# 	sigset_t pending, shpending, blocked, ignored, caught;
# 	int num_threads = 0;
# 	unsigned long qsize = 0;
# 	unsigned long qlim = 0;
# 
# 	sigemptyset(&pending);
# 	sigemptyset(&shpending);
# 	sigemptyset(&blocked);
# 	sigemptyset(&ignored);
# 	sigemptyset(&caught);
# 
# 	if (lock_task_sighand(p, &flags)) {
# 		pending = p->pending.signal;
# 		shpending = p->signal->shared_pending.signal;
# 		blocked = p->blocked;
# 		collect_sigign_sigcatch(p, &ignored, &caught);
# 		num_threads = get_nr_threads(p);
# 		rcu_read_lock();  /* FIXME: is this correct? */
# 		qsize = atomic_read(&__task_cred(p)->user->sigpending);
# 		rcu_read_unlock();
# 		qlim = task_rlimit(p, RLIMIT_SIGPENDING);
# 		unlock_task_sighand(p, &flags);
# 	}
# 
# 	seq_printf(m, "Threads:\t%d\n", num_threads);
# 	seq_printf(m, "SigQ:\t%lu/%lu\n", qsize, qlim);
# 
# 	/* render them all */
# 	render_sigset_t(m, "SigPnd:\t", &pending);
# 	render_sigset_t(m, "ShdPnd:\t", &shpending);
# 	render_sigset_t(m, "SigBlk:\t", &blocked);
# 	render_sigset_t(m, "SigIgn:\t", &ignored);
# 	render_sigset_t(m, "SigCgt:\t", &caught);
# }
# 
# 
# static inline void task_cap(struct seq_file *m, struct task_struct *p)
# {
# 	const struct cred *cred;
# 	kernel_cap_t cap_inheritable, cap_permitted, cap_effective, cap_bset;
# 
# 	rcu_read_lock();
# 	cred = __task_cred(p);
# 	cap_inheritable	= cred->cap_inheritable;
# 	cap_permitted	= cred->cap_permitted;
# 	cap_effective	= cred->cap_effective;
# 	cap_bset	= cred->cap_bset;
# 	rcu_read_unlock();
# 
# 	render_cap_t(m, "CapInh:\t", &cap_inheritable);
# 	render_cap_t(m, "CapPrm:\t", &cap_permitted);
# 	render_cap_t(m, "CapEff:\t", &cap_effective);
# 	render_cap_t(m, "CapBnd:\t", &cap_bset);
# }
# 
# 
# static void task_cpus_allowed(struct seq_file *m, struct task_struct *task)
# {
# 	seq_puts(m, "Cpus_allowed:\t");
# 	seq_cpumask(m, &task->cpus_allowed);
# 	seq_putc(m, '\n');
# 	seq_puts(m, "Cpus_allowed_list:\t");
# 	seq_cpumask_list(m, &task->cpus_allowed);
# 	seq_putc(m, '\n');
# }
# 
# 
# static inline void task_context_switch_counts(struct seq_file *m,
# 						struct task_struct *p)
# {
# 	seq_printf(m,	"voluntary_ctxt_switches:\t%lu\n"
# 			"nonvoluntary_ctxt_switches:\t%lu\n",
# 			p->nvcsw,
# 			p->nivcsw);
# }


# from: fs/proc/task_mmu.c
# ---------
#
# void task_mem(struct seq_file *m, struct mm_struct *mm)
# {
# 	unsigned long data, text, lib, swap;
# 	unsigned long hiwater_vm, total_vm, hiwater_rss, total_rss;
# 
# 	/*
# 	 * Note: to minimize their overhead, mm maintains hiwater_vm and
# 	 * hiwater_rss only when about to *lower* total_vm or rss.  Any
# 	 * collector of these hiwater stats must therefore get total_vm
# 	 * and rss too, which will usually be the higher.  Barriers? not
# 	 * worth the effort, such snapshots can always be inconsistent.
# 	 */
# 	hiwater_vm = total_vm = mm->total_vm;
# 	if (hiwater_vm < mm->hiwater_vm)
# 		hiwater_vm = mm->hiwater_vm;
# 	hiwater_rss = total_rss = get_mm_rss(mm);
# 	if (hiwater_rss < mm->hiwater_rss)
# 		hiwater_rss = mm->hiwater_rss;
# 
# 	data = mm->total_vm - mm->shared_vm - mm->stack_vm;
# 	text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK)) >> 10;
# 	lib = (mm->exec_vm << (PAGE_SHIFT-10)) - text;
# 	swap = get_mm_counter(mm, MM_SWAPENTS);
# 	seq_printf(m,
# 		"VmPeak:\t%8lu kB\n"
# 		"VmSize:\t%8lu kB\n"
# 		"VmLck:\t%8lu kB\n"
# 		"VmPin:\t%8lu kB\n"
# 		"VmHWM:\t%8lu kB\n"
# 		"VmRSS:\t%8lu kB\n"
# 		"VmData:\t%8lu kB\n"
# 		"VmStk:\t%8lu kB\n"
# 		"VmExe:\t%8lu kB\n"
# 		"VmLib:\t%8lu kB\n"
# 		"VmPTE:\t%8lu kB\n"
# 		"VmSwap:\t%8lu kB\n",
# 		hiwater_vm << (PAGE_SHIFT-10),
# 		(total_vm - mm->reserved_vm) << (PAGE_SHIFT-10),
# 		mm->locked_vm << (PAGE_SHIFT-10),
# 		mm->pinned_vm << (PAGE_SHIFT-10),
# 		hiwater_rss << (PAGE_SHIFT-10),
# 		total_rss << (PAGE_SHIFT-10),
# 		data << (PAGE_SHIFT-10),
# 		mm->stack_vm << (PAGE_SHIFT-10), text, lib,
# 		(PTRS_PER_PTE*sizeof(pte_t)*mm->nr_ptes) >> 10,
# 		swap << (PAGE_SHIFT-10));
# }

# from: kernel/cpuset.c
# ---------
#
# void cpuset_task_status_allowed(struct seq_file *m, struct task_struct *task)
# {
# 	seq_printf(m, "Mems_allowed:\t");
# 	seq_nodemask(m, &task->mems_allowed);
# 	seq_printf(m, "\n");
# 	seq_printf(m, "Mems_allowed_list:\t");
# 	seq_nodemask_list(m, &task->mems_allowed);
# 	seq_printf(m, "\n");
# }



--- File: /proc/self/sched

source: fs/proc/base.c
--and--
source: kernel/sched_debug.c

Excerpts from that code:

# from: fs/proc/base.c
# ---------
#
#static int sched_show(struct seq_file *m, void *v)
#{
#        struct inode *inode = m->private;
#        struct task_struct *p;
#
#        p = get_proc_task(inode);
#        if (!p)
#                return -ESRCH;
#        proc_sched_show_task(p, m);
#
#        put_task_struct(p);
#
#        return 0;
#}


# from: kernel/sched_debug.c
# ---------
#
#void proc_sched_show_task(struct task_struct *p, struct seq_file *m)
#{
#        unsigned long nr_switches;
#
#        SEQ_printf(m, "%s (%d, #threads: %d)\n", p->comm, p->pid,
#                                                get_nr_threads(p));
#        SEQ_printf(m,
#                "---------------------------------------------------------\n");
##define __P(F) \
#        SEQ_printf(m, "%-35s:%21Ld\n", #F, (long long)F)
##define P(F) \
#        SEQ_printf(m, "%-35s:%21Ld\n", #F, (long long)p->F)
##define __PN(F) \
#        SEQ_printf(m, "%-35s:%14Ld.%06ld\n", #F, SPLIT_NS((long long)F))
##define PN(F) \
#        SEQ_printf(m, "%-35s:%14Ld.%06ld\n", #F, SPLIT_NS((long long)p->F))
#
#        PN(se.exec_start);
#        PN(se.vruntime);
#        PN(se.sum_exec_runtime);
#
#        nr_switches = p->nvcsw + p->nivcsw;
#
##ifdef CONFIG_SCHEDSTATS
#        PN(se.statistics.wait_start);
#        PN(se.statistics.sleep_start);
#        PN(se.statistics.block_start);
#        PN(se.statistics.sleep_max);
#        PN(se.statistics.block_max);
#        PN(se.statistics.exec_max);
#        PN(se.statistics.slice_max);
#        PN(se.statistics.wait_max);
#        PN(se.statistics.wait_sum);
#        P(se.statistics.wait_count);
#        PN(se.statistics.iowait_sum);
#        P(se.statistics.iowait_count);
#        P(se.nr_migrations);
#        P(se.statistics.nr_migrations_cold);
#        P(se.statistics.nr_failed_migrations_affine);
#        P(se.statistics.nr_failed_migrations_running);
#        P(se.statistics.nr_failed_migrations_hot);
#        P(se.statistics.nr_forced_migrations);
#        P(se.statistics.nr_wakeups);
#        P(se.statistics.nr_wakeups_sync);
#        P(se.statistics.nr_wakeups_migrate);
#        P(se.statistics.nr_wakeups_local);
#        P(se.statistics.nr_wakeups_remote);
#        P(se.statistics.nr_wakeups_affine);
#        P(se.statistics.nr_wakeups_affine_attempts);
#        P(se.statistics.nr_wakeups_passive);
#        P(se.statistics.nr_wakeups_idle);
#
#        {
#                u64 avg_atom, avg_per_cpu;
#
#                avg_atom = p->se.sum_exec_runtime;
#                if (nr_switches)
#                        do_div(avg_atom, nr_switches);
#                else
#                        avg_atom = -1LL;
#
#                avg_per_cpu = p->se.sum_exec_runtime;
#                if (p->se.nr_migrations) {
#                        avg_per_cpu = div64_u64(avg_per_cpu,
#                                                p->se.nr_migrations);
#                } else {
#                        avg_per_cpu = -1LL;
#                }
#
#                __PN(avg_atom);
#                __PN(avg_per_cpu);
#        }
##endif
#        __P(nr_switches);
#        SEQ_printf(m, "%-35s:%21Ld\n",
#                   "nr_voluntary_switches", (long long)p->nvcsw);
#        SEQ_printf(m, "%-35s:%21Ld\n",
#                   "nr_involuntary_switches", (long long)p->nivcsw);
#
#        P(se.load.weight);
#        P(policy);
#        P(prio);
##undef PN
##undef __PN
##undef P
##undef __P
#
#        {
#                unsigned int this_cpu = raw_smp_processor_id();
#                u64 t0, t1;
#
#                t0 = cpu_clock(this_cpu);
#                t1 = cpu_clock(this_cpu);
#                SEQ_printf(m, "%-35s:%21Ld\n",
#                           "clock-delta", (long long)(t1-t0));
#        }
#}



--- File: /proc/self/stat

Note: Kernel updates restructed the sample code and added 8 new fields to the
output file.  Both versions are included below to help people understand why
their particular system includes the data it does.

source: fs/proc/array.c

Excerpts from that code:

--- older kernel ---
#static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,
#                        struct pid *pid, struct task_struct *task, int whole)
#{
#        unsigned long vsize, eip, esp, wchan = ~0UL;
#        long priority, nice;
#        int tty_pgrp = -1, tty_nr = 0;
#        sigset_t sigign, sigcatch;
#        char state;
#        pid_t ppid = 0, pgid = -1, sid = -1;
#        int num_threads = 0;
#        int permitted;
#        struct mm_struct *mm;
#        unsigned long long start_time;
#        unsigned long cmin_flt = 0, cmaj_flt = 0;
#        unsigned long  min_flt = 0,  maj_flt = 0;
#        cputime_t cutime, cstime, utime, stime;
#        cputime_t cgtime, gtime;
#        unsigned long rsslim = 0;
#        char tcomm[sizeof(task->comm)];
#        unsigned long flags;
#
#        state = *get_task_state(task);
#        vsize = eip = esp = 0;
#        permitted = ptrace_may_access(task, PTRACE_MODE_READ);
#        mm = get_task_mm(task);
#        if (mm) {
#                vsize = task_vsize(mm);
#                if (permitted) {
#                        eip = KSTK_EIP(task);
#                        esp = KSTK_ESP(task);
#                }
#        }
#
#        get_task_comm(tcomm, task);
#
#        sigemptyset(&sigign);
#        sigemptyset(&sigcatch);
#        cutime = cstime = utime = stime = cputime_zero;
#        cgtime = gtime = cputime_zero;
#
#        if (lock_task_sighand(task, &flags)) {
#                struct signal_struct *sig = task->signal;
#
#                if (sig->tty) {
#                        struct pid *pgrp = tty_get_pgrp(sig->tty);
#                        tty_pgrp = pid_nr_ns(pgrp, ns);
#                        put_pid(pgrp);
#                        tty_nr = new_encode_dev(tty_devnum(sig->tty));
#                }
#
#                num_threads = get_nr_threads(task);
#                collect_sigign_sigcatch(task, &sigign, &sigcatch);
#
#                cmin_flt = sig->cmin_flt;
#                cmaj_flt = sig->cmaj_flt;
#                cutime = sig->cutime;
#                cstime = sig->cstime;
#                cgtime = sig->cgtime;
#                rsslim = ACCESS_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);
#
#                /* add up live thread stats at the group level */
#                if (whole) {
#                        struct task_struct *t = task;
#                        do {
#                                min_flt += t->min_flt;
#                                maj_flt += t->maj_flt;
#                                gtime = cputime_add(gtime, t->gtime);
#                                t = next_thread(t);
#                        } while (t != task);
#
#                        min_flt += sig->min_flt;
#                        maj_flt += sig->maj_flt;
#                        thread_group_times(task, &utime, &stime);
#                        gtime = cputime_add(gtime, sig->gtime);
#                }
#
#                sid = task_session_nr_ns(task, ns);
#                ppid = task_tgid_nr_ns(task->real_parent, ns);
#                pgid = task_pgrp_nr_ns(task, ns);
#
#                unlock_task_sighand(task, &flags);
#        }
#
#        if (permitted && (!whole || num_threads < 2))
#                wchan = get_wchan(task);
#        if (!whole) {
#                min_flt = task->min_flt;
#                maj_flt = task->maj_flt;
#                task_times(task, &utime, &stime);
#                gtime = task->gtime;
#        }
#
#        /* scale priority and nice values from timeslices to -20..20 */
#        /* to make it look like a "normal" Unix priority/nice value  */
#        priority = task_prio(task);
#        nice = task_nice(task);
#
#        /* Temporary variable needed for gcc-2.96 */
#        /* convert timespec -> nsec*/
#        start_time =
#                (unsigned long long)task->real_start_time.tv_sec * NSEC_PER_SEC
#                                + task->real_start_time.tv_nsec;
#        /* convert nsec -> ticks */
#        start_time = nsec_to_clock_t(start_time);
#
#        seq_printf(m, "%d (%s) %c %d %d %d %d %d %u %lu \
#%lu %lu %lu %lu %lu %ld %ld %ld %ld %d 0 %llu %lu %ld %lu %lu %lu %lu %lu \
#%lu %lu %lu %lu %lu %lu %lu %lu %d %d %u %u %llu %lu %ld\n",
#                pid_nr_ns(pid, ns),
#                tcomm,
#                state,
#                ppid,
#                pgid,
#                sid,
#                tty_nr,
#                tty_pgrp,
#                task->flags,
#                min_flt,
#                cmin_flt,
#                maj_flt,
#                cmaj_flt,
#                cputime_to_clock_t(utime),
#                cputime_to_clock_t(stime),
#                cputime_to_clock_t(cutime),
#                cputime_to_clock_t(cstime),
#                priority,
#                nice,
#                num_threads,
#                start_time,
#                vsize,
#                mm ? get_mm_rss(mm) : 0,
#                rsslim,
#                mm ? (permitted ? mm->start_code : 1) : 0,
#                mm ? (permitted ? mm->end_code : 1) : 0,
#                (permitted && mm) ? mm->start_stack : 0,
#                esp,
#                eip,
#                /* The signal information here is obsolete.
#                 * It must be decimal for Linux 2.0 compatibility.
#                 * Use /proc/#/status for real-time signals.
#                 */
#                task->pending.signal.sig[0] & 0x7fffffffUL,
#                task->blocked.sig[0] & 0x7fffffffUL,
#                sigign      .sig[0] & 0x7fffffffUL,
#                sigcatch    .sig[0] & 0x7fffffffUL,
#                wchan,
#                0UL,
#                0UL,
#                task->exit_signal,
#                task_cpu(task),
#                task->rt_priority,
#                task->policy,
#                (unsigned long long)delayacct_blkio_ticks(task),
#                cputime_to_clock_t(gtime),
#                cputime_to_clock_t(cgtime));
#        if (mm)
#                mmput(mm);
#        return 0;
#}

--- newer kernel ---
# static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,
# 			struct pid *pid, struct task_struct *task, int whole)
# {
# 	unsigned long vsize, eip, esp, wchan = ~0UL;
# 	int priority, nice;
# 	int tty_pgrp = -1, tty_nr = 0;
# 	sigset_t sigign, sigcatch;
# 	char state;
# 	pid_t ppid = 0, pgid = -1, sid = -1;
# 	int num_threads = 0;
# 	int permitted;
# 	struct mm_struct *mm;
# 	unsigned long long start_time;
# 	unsigned long cmin_flt = 0, cmaj_flt = 0;
# 	unsigned long  min_flt = 0,  maj_flt = 0;
# 	cputime_t cutime, cstime, utime, stime;
# 	cputime_t cgtime, gtime;
# 	unsigned long rsslim = 0;
# 	char tcomm[sizeof(task->comm)];
# 	unsigned long flags;
# 
# 	state = *get_task_state(task);
# 	vsize = eip = esp = 0;
# 	permitted = ptrace_may_access(task, PTRACE_MODE_READ | PTRACE_MODE_NOAUDIT);
# 	mm = get_task_mm(task);
# 	if (mm) {
# 		vsize = task_vsize(mm);
# 		if (permitted) {
# 			eip = KSTK_EIP(task);
# 			esp = KSTK_ESP(task);
# 		}
# 	}
# 
# 	get_task_comm(tcomm, task);
# 
# 	sigemptyset(&sigign);
# 	sigemptyset(&sigcatch);
# 	cutime = cstime = utime = stime = 0;
# 	cgtime = gtime = 0;
# 
# 	if (lock_task_sighand(task, &flags)) {
# 		struct signal_struct *sig = task->signal;
# 
# 		if (sig->tty) {
# 			struct pid *pgrp = tty_get_pgrp(sig->tty);
# 			tty_pgrp = pid_nr_ns(pgrp, ns);
# 			put_pid(pgrp);
# 			tty_nr = new_encode_dev(tty_devnum(sig->tty));
# 		}
# 
# 		num_threads = get_nr_threads(task);
# 		collect_sigign_sigcatch(task, &sigign, &sigcatch);
# 
# 		cmin_flt = sig->cmin_flt;
# 		cmaj_flt = sig->cmaj_flt;
# 		cutime = sig->cutime;
# 		cstime = sig->cstime;
# 		cgtime = sig->cgtime;
# 		rsslim = ACCESS_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);
# 
# 		/* add up live thread stats at the group level */
# 		if (whole) {
# 			struct task_struct *t = task;
# 			do {
# 				min_flt += t->min_flt;
# 				maj_flt += t->maj_flt;
# 				gtime += task_gtime(t);
# 				t = next_thread(t);
# 			} while (t != task);
# 
# 			min_flt += sig->min_flt;
# 			maj_flt += sig->maj_flt;
# 			thread_group_cputime_adjusted(task, &utime, &stime);
# 			gtime += sig->gtime;
# 		}
# 
# 		sid = task_session_nr_ns(task, ns);
# 		ppid = task_tgid_nr_ns(task->real_parent, ns);
# 		pgid = task_pgrp_nr_ns(task, ns);
# 
# 		unlock_task_sighand(task, &flags);
# 	}
# 
# 	if (permitted && (!whole || num_threads < 2))
# 		wchan = get_wchan(task);
# 	if (!whole) {
# 		min_flt = task->min_flt;
# 		maj_flt = task->maj_flt;
# 		task_cputime_adjusted(task, &utime, &stime);
# 		gtime = task_gtime(task);
# 	}
# 
# 	/* scale priority and nice values from timeslices to -20..20 */
# 	/* to make it look like a "normal" Unix priority/nice value  */
# 	priority = task_prio(task);
# 	nice = task_nice(task);
# 
# 	/* Temporary variable needed for gcc-2.96 */
# 	/* convert timespec -> nsec*/
# 	start_time =
# 		(unsigned long long)task->real_start_time.tv_sec * NSEC_PER_SEC
# 				+ task->real_start_time.tv_nsec;
# 	/* convert nsec -> ticks */
# 	start_time = nsec_to_clock_t(start_time);
# 
# 	seq_printf(m, "%d (%s) %c", pid_nr_ns(pid, ns), tcomm, state);
# 	seq_put_decimal_ll(m, ' ', ppid);
# 	seq_put_decimal_ll(m, ' ', pgid);
# 	seq_put_decimal_ll(m, ' ', sid);
# 	seq_put_decimal_ll(m, ' ', tty_nr);
# 	seq_put_decimal_ll(m, ' ', tty_pgrp);
# 	seq_put_decimal_ull(m, ' ', task->flags);
# 	seq_put_decimal_ull(m, ' ', min_flt);
# 	seq_put_decimal_ull(m, ' ', cmin_flt);
# 	seq_put_decimal_ull(m, ' ', maj_flt);
# 	seq_put_decimal_ull(m, ' ', cmaj_flt);
# 	seq_put_decimal_ull(m, ' ', cputime_to_clock_t(utime));
# 	seq_put_decimal_ull(m, ' ', cputime_to_clock_t(stime));
# 	seq_put_decimal_ll(m, ' ', cputime_to_clock_t(cutime));
# 	seq_put_decimal_ll(m, ' ', cputime_to_clock_t(cstime));
# 	seq_put_decimal_ll(m, ' ', priority);
# 	seq_put_decimal_ll(m, ' ', nice);
# 	seq_put_decimal_ll(m, ' ', num_threads);
# 	seq_put_decimal_ull(m, ' ', 0);
# 	seq_put_decimal_ull(m, ' ', start_time);
# 	seq_put_decimal_ull(m, ' ', vsize);
# 	seq_put_decimal_ull(m, ' ', mm ? get_mm_rss(mm) : 0);
# 	seq_put_decimal_ull(m, ' ', rsslim);
# 	seq_put_decimal_ull(m, ' ', mm ? (permitted ? mm->start_code : 1) : 0);
# 	seq_put_decimal_ull(m, ' ', mm ? (permitted ? mm->end_code : 1) : 0);
# 	seq_put_decimal_ull(m, ' ', (permitted && mm) ? mm->start_stack : 0);
# 	seq_put_decimal_ull(m, ' ', esp);
# 	seq_put_decimal_ull(m, ' ', eip);
# 	/* The signal information here is obsolete.
# 	 * It must be decimal for Linux 2.0 compatibility.
# 	 * Use /proc/#/status for real-time signals.
# 	 */
# 	seq_put_decimal_ull(m, ' ', task->pending.signal.sig[0] & 0x7fffffffUL);
# 	seq_put_decimal_ull(m, ' ', task->blocked.sig[0] & 0x7fffffffUL);
# 	seq_put_decimal_ull(m, ' ', sigign.sig[0] & 0x7fffffffUL);
# 	seq_put_decimal_ull(m, ' ', sigcatch.sig[0] & 0x7fffffffUL);
# 	seq_put_decimal_ull(m, ' ', wchan);
# 	seq_put_decimal_ull(m, ' ', 0);
# 	seq_put_decimal_ull(m, ' ', 0);
# 	seq_put_decimal_ll(m, ' ', task->exit_signal);
# 	seq_put_decimal_ll(m, ' ', task_cpu(task));
# 	seq_put_decimal_ull(m, ' ', task->rt_priority);
# 	seq_put_decimal_ull(m, ' ', task->policy);
# 	seq_put_decimal_ull(m, ' ', delayacct_blkio_ticks(task));
# 	seq_put_decimal_ull(m, ' ', cputime_to_clock_t(gtime));
# 	seq_put_decimal_ll(m, ' ', cputime_to_clock_t(cgtime));
# 
# 	if (mm && permitted) {
# 		seq_put_decimal_ull(m, ' ', mm->start_data);
# 		seq_put_decimal_ull(m, ' ', mm->end_data);
# 		seq_put_decimal_ull(m, ' ', mm->start_brk);
# 		seq_put_decimal_ull(m, ' ', mm->arg_start);
# 		seq_put_decimal_ull(m, ' ', mm->arg_end);
# 		seq_put_decimal_ull(m, ' ', mm->env_start);
# 		seq_put_decimal_ull(m, ' ', mm->env_end);
# 	} else
# 		seq_printf(m, " 0 0 0 0 0 0 0");
# 
# 	if (permitted)
# 		seq_put_decimal_ll(m, ' ', task->exit_code);
# 	else
# 		seq_put_decimal_ll(m, ' ', 0);
# 
# 	seq_putc(m, '\n');
# 	if (mm)
# 		mmput(mm);
# 	return 0;
# }

